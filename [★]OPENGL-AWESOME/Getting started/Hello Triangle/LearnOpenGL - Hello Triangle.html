<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <script type="text/javascript" async="" src="LearnOpenGL%20-%20Hello%20Triangle_files/localstore.js"></script>
  <meta charset="utf-8">
  <title>LearnOpenGL - Hello Triangle</title>
  <!--<title>Learn OpenGL, extensive tutorial resource for learning Modern OpenGL</title>-->
  <link rel="shortcut icon" type="image/ico" href="https://learnopengl.com/favicon.ico">
  <meta name="description"
    content="Learn OpenGL . com provides good and clear modern 3.3+ OpenGL tutorials with clear examples. A great resource to learn modern OpenGL aimed at beginners.">
  <meta name="fragment" content="!">
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/rules-p-fTfJtcPmQDwZG.js" async=""></script>
  <script async="" src="LearnOpenGL%20-%20Hello%20Triangle_files/wrap.js"></script>
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/quant.js" async="" type="text/javascript"></script>
  <script async="" type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/cmp2.js"></script>
  <script type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/config.js"></script>
  <script async="" type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/gpt_002.js"></script>
  <script async="" type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/pwt.js"></script>
  <script async="" type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/choice.js"></script>
  <script async="" src="LearnOpenGL%20-%20Hello%20Triangle_files/analytics.js"></script>
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-51879160-1', 'learnopengl.com');
    ga('send', 'pageview');

  </script>
  <!--<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>-->
  <script>
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-pub-7855791439695850",
      enable_page_level_ads: true
    });
  </script>
  <script async="async" src="LearnOpenGL%20-%20Hello%20Triangle_files/gpt.js"></script>
  <script>
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
  </script>
  <script>
    googletag.cmd.push(function () {
      googletag.defineSlot('/8491498/learnopengl_video', [300, 225], 'div-gpt-ad-1540574378241-0').addService(googletag.pubads());
      googletag.pubads().enableSingleRequest();
      googletag.pubads().collapseEmptyDivs();
      googletag.enableServices();
    });
  </script>
  <script type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/1681.js"></script>
  <style type="text/css">
    #waldo-sticky-footer-wrapper {
      position: fixed;
      width: 100%;
      bottom: 0px;
      left: 0px;
      text-align: center;
      z-index: 9999;
      margin-bottom: 0 !important;
    }

    #waldo-sticky-footer-wrapper>div {
      position: relative;
      display: inline-block;
      margin-bottom: 0 !important;
    }

    #waldo-sticky-footer-wrapper iframe,
    #waldo-sticky-footer-wrapper div {
      margin-left: auto;
      margin-right: auto;
    }

    .waldo-sticky-sidebar {
      position: fixed;
      top: 10px;
      z-index: 90
    }

    .waldo-bfleft {
      position: fixed;
      left: 0;
      top: 10px;
      z-index: 101;
    }

    .waldo-bfright {
      position: fixed;
      right: 0;
      top: 10px;
      z-index: 101;
    }

    #nm-ccpa-widget {
      width: 400px;
    }

    #nm-ccpa-widget {
      position: fixed;
      right: 20px;
      z-index: 9999;
      margin-bottom: 15px;
      box-shadow: 0 3px 36px 0 rgba(0, 0, 0, 0.3);
      background-color: #fff;
      border-radius: 10px;
      bottom: 20px;
      margin-top: 10px;
      font-size: 14px;
    }

    .nm-ccpa-widget-header {
      background: #179f84;
      color: #fff;
      padding: 20px;
    }

    .nm-ccpa-widget-header .nm-ccpa-widget-main-title {
      margin-bottom: 0;
      margin-top: 0;
      font-size: 16px;
      font-weight: bold;
    }

    .nm-ccpa-widget-body {
      padding: 20px;
      background: #fff;
    }

    .nm-ccpa-widget-body label {
      font-size: 16px;
    }

    .nm-ccpa-widget-submit-btn {
      margin-top: 15px;
      padding-left: 25px;
    }

    .nm-ccpa-widget-submit-btn input {
      background: #179f84;
      color: #fff;
      padding: 10px 20px;
      border-radius: 8px;
      border: 0;
      outline: 0;
    }

    .nm-ccpa-widget-submit-btn input:hover,
    .nm-ccpa-widget-submit-btn input:focus {
      cursor: pointer;
    }

    .nm-ccpa-widget-checkbox-label {
      font-size: 20px;
    }

    .nm-ccpa-widget-header {
      position: relative;
    }

    .nm-ccpa-widget-close-btn {
      position: absolute;
      right: 10px;
      top: 10px;
    }

    .nm-ccpa-widget-close-btn a {
      color: #fff;
      font-size: 20px;
      text-decoration: none;
    }

    .nm-ccpa-widget-message {
      padding-left: 25px;
    }

    #waldo-tag-6038 {
      clear: both !important;
    }

    div[class^="app_gdpr-"] a {
      color: #41afbb !important;
      text-decoration: underline !important
    }

    #waldo-close-button {
      position: absolute;
      right: 0;
      top: -24px;
      line-height: normal !important;
    }

    #waldo-close-button a {
      border: 1px solid rgba(0, 0, 0, .35) !important;
      padding: 3px !important;
      font-size: 12px !important;
      color: #fff !important;
      font-weight: bold !important;
      background-color: #777 !important;
      line-height: normal !important;
    }

    .waldo-display-unit {
      display: flex !important;
      justify-content: center !important;
      align-items: center !important;
      flex-wrap: wrap !important;
    }
  </style>
  <script type="text/javascript" async="" src="LearnOpenGL%20-%20Hello%20Triangle_files/tag"></script>
  <script type="text/javascript" async="" src="LearnOpenGL%20-%20Hello%20Triangle_files/tag.js"></script>
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/jquery-1.11.0.min.js"></script>
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/hoverintent.js"></script>
  <link rel="stylesheet" type="text/css" href="LearnOpenGL%20-%20Hello%20Triangle_files/layout.css">
  <link rel="stylesheet" type="text/css" href="LearnOpenGL%20-%20Hello%20Triangle_files/obsidian.css">
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/highlight.pack.js"></script>
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/functions.js"></script>
  <script type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/MathJax.js"></script>
  <script>
    // Has to be loaded last due to content bug 
    MathJax.Hub.Config({
      TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
  </script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>
    $(document).ready(function () {
      // check if user visited from the old # based urls, re-direct to ?p= form
      if (window.location.hash) {
        var name = window.location.hash.substring(2);
        // name = name.replace(/-/g," ");
        var index = name.indexOf('#'); // Remove any hash fragments from the url (Disquss adds hash fragments for comments, but results in 404 pages)
        if (index >= 0)
          name = name.substring(0, index);

        window.location.href = "https://learnopengl.com/" + name;
      } else {
        // Check if data has been succesfully loaded, if so: change title bar as ajax hash fragment
        var title = $('#content-url').text();

        // Refresh syntax highlighting
        // $('pre').each(function(i, e) {hljs.highlightBlock(e)});

        // Reset DISQUS
        // if(title == '/dev/')
        // title = '';
        // alert('hoi');

        // place video tag 
        if (title != '') {
          //var videoad = "%3Cdiv id=\'waldo-tag-14070\'%3E %3Cscript%3Egoogletag.cmd.push(function() {googletag.display(\'waldo-tag-14070\'); }); %3C/script%3E%3C/div%3E";
          //$('#content p:nth-of-type(3)').after(unescape(videoad));
        }

        // Adjust ads for correct bottom positioning based on content size
        window.setTimeout(function () {
          AdPositioning();
        }, 3000);


        // set API resets after time-out (once content is properly loaded)
        window.setTimeout(function () {
          MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
          // if (MathJax.InputJax.TeX.resetEquationNumbers)
          // {						
          // MathJax.Hub.Queue(["resetEquationNumbers", MathJax.InputJax.TeX]);
          // }

          var page_url = title == "" ? "http://www.learnopengl.com/" : "http://www.learnopengl.com/" + title;
          if (typeof DISQUS !== 'undefined') {
            DISQUS.reset({
              reload: true,
              config: function () {
                this.page.identifier = title;
                this.page.url = page_url;
              }
            });
            $('#disqus_thread').show();
          }
          // Refresh callbacks on <function> tags
          SetFunctionTagCallbacks();
        }, 1000);

        // Zet ook de juiste button op 'selected'
        $('#nav li span, #nav li a').removeClass('selected');
        if (title != '') {
          $('#nav li[id=\'' + title + '\']').children('span, a').addClass('selected');
        }
        // En open menu waar nodig
        var parents = $('#nav span.selected, #nav a.selected').parents('li').children('span.closed, a.closed');
        var index = 0;
        for (index = parents.length - 1; index >= 0; index--) {

          var id = $(parents[index]).attr("id").replace(/^\D+/g, '');
          MenuClick(id, false);
        }

      }
    });
    // var initialized = false;
    // window.onpopstate = function() {
    // if(initialized)
    // LoadPage();
    // else
    // initialized = true;
    // };

    // Set up DISQUS
    // $(document).ready(function() {
    var disqus_shortname = 'learnopengl';
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
        // });
  </script>
  <script type="text/javascript" async="" src="LearnOpenGL%20-%20Hello%20Triangle_files/embed.js"></script>
  <script
    type="text/javascript">googletag.cmd.push(function () { googletag.pubads().addEventListener('slotRenderEnded', function (event) { waldoPassbackCheck(event); waldoAddCloseBtn(event); }); googletag.pubads().enableSingleRequest(); googletag.enableServices(); gptAdSlots[1715] = googletag.defineSlot('/124067137,22550200400/learnopengl300x250FL_1', [[300, 250], [300, 600], [160, 600]], 'waldo-tag-1715').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600], [160, 600]]).addSize([768, 0], [[300, 250], [300, 600], [160, 600]]).addSize([0, 0], [[300, 250], [300, 600], [160, 600]]).build()).addService(googletag.pubads()); googletag.display('waldo-tag-1715'); gptAdSlots[2245] = googletag.defineSlot('/124067137,22550200400/learnopengl300x600FL_1', [[300, 250], [300, 600]], 'waldo-tag-2245').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600]]).addSize([768, 0], [[300, 250], [300, 600]]).addSize([0, 0], [[300, 250], [300, 600]]).build()).addService(googletag.pubads()); googletag.display('waldo-tag-2245'); gptAdSlots[2246] = googletag.defineSlot('/124067137,22550200400/learnopengl300x600FL_2', [[300, 250], [300, 600]], 'waldo-tag-2246').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600]]).addSize([768, 0], [[300, 250], [300, 600]]).addSize([0, 0], [[300, 250], [300, 600]]).build()).addService(googletag.pubads()); googletag.display('waldo-tag-2246'); gptAdSlots[2247] = googletag.defineSlot('/124067137,22550200400/learnopengl300x600FL_3', [[300, 250], [300, 600]], 'waldo-tag-2247').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[300, 250], [300, 600]]).addSize([768, 0], [[300, 250], [300, 600]]).addSize([0, 0], [[300, 250], [300, 600]]).build()).addService(googletag.pubads()); googletag.display('waldo-tag-2247'); gptAdSlots[6194] = googletag.defineSlot('/124067137,22550200400/learnopengl728x90FS_2', [[728, 90], [320, 50]], 'waldo-tag-6194').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[728, 90]]).addSize([768, 0], [[320, 50]]).addSize([0, 0], [[320, 50]]).build()).addService(googletag.pubads()); googletag.display('waldo-tag-6194'); gptAdSlots[6196] = googletag.defineSlot('/124067137,22550200400/learnopengl728x90FS_1', [[728, 90], [320, 50]], 'waldo-tag-6196').defineSizeMapping(googletag.sizeMapping().addSize([1024, 0], [[728, 90]]).addSize([768, 0], [[320, 50]]).addSize([0, 0], [[320, 50]]).build()).addService(googletag.pubads()); googletag.display('waldo-tag-6196'); waldoVideoSlot = googletag.defineSlot('/124067137,22550200400/learnopengl_video_unit2', [1, 1], 'waldo-tag-14070').defineSizeMapping(googletag.sizeMapping().addSize([0, 0], [300, 235]).addSize([320, 700], [300, 235]).addSize([1050, 200], [566, 387]).build()).addService(googletag.pubads()); });</script>
  <style type="text/css">
    .MathJax_Hover_Frame {
      border-radius: .25em;
      -webkit-border-radius: .25em;
      -moz-border-radius: .25em;
      -khtml-border-radius: .25em;
      box-shadow: 0px 0px 15px #83A;
      -webkit-box-shadow: 0px 0px 15px #83A;
      -moz-box-shadow: 0px 0px 15px #83A;
      -khtml-box-shadow: 0px 0px 15px #83A;
      border: 1px solid #A6D ! important;
      display: inline-block;
      position: absolute
    }

    .MathJax_Menu_Button .MathJax_Hover_Arrow {
      position: absolute;
      cursor: pointer;
      display: inline-block;
      border: 2px solid #AAA;
      border-radius: 4px;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      -khtml-border-radius: 4px;
      font-family: 'Courier New', Courier;
      font-size: 9px;
      color: #F0F0F0
    }

    .MathJax_Menu_Button .MathJax_Hover_Arrow span {
      display: block;
      background-color: #AAA;
      border: 1px solid;
      border-radius: 3px;
      line-height: 0;
      padding: 4px
    }

    .MathJax_Hover_Arrow:hover {
      color: white !important;
      border: 2px solid #CCC !important
    }

    .MathJax_Hover_Arrow:hover span {
      background-color: #CCC !important
    }
  </style>
  <style type="text/css">
    #MathJax_About {
      position: fixed;
      left: 50%;
      width: auto;
      text-align: center;
      border: 3px outset;
      padding: 1em 2em;
      background-color: #DDDDDD;
      color: black;
      cursor: default;
      font-family: message-box;
      font-size: 120%;
      font-style: normal;
      text-indent: 0;
      text-transform: none;
      line-height: normal;
      letter-spacing: normal;
      word-spacing: normal;
      word-wrap: normal;
      white-space: nowrap;
      float: none;
      z-index: 201;
      border-radius: 15px;
      -webkit-border-radius: 15px;
      -moz-border-radius: 15px;
      -khtml-border-radius: 15px;
      box-shadow: 0px 10px 20px #808080;
      -webkit-box-shadow: 0px 10px 20px #808080;
      -moz-box-shadow: 0px 10px 20px #808080;
      -khtml-box-shadow: 0px 10px 20px #808080;
      filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')
    }

    #MathJax_About.MathJax_MousePost {
      outline: none
    }

    .MathJax_Menu {
      position: absolute;
      background-color: white;
      color: black;
      width: auto;
      padding: 2px;
      border: 1px solid #CCCCCC;
      margin: 0;
      cursor: default;
      font: menu;
      text-align: left;
      text-indent: 0;
      text-transform: none;
      line-height: normal;
      letter-spacing: normal;
      word-spacing: normal;
      word-wrap: normal;
      white-space: nowrap;
      float: none;
      z-index: 201;
      box-shadow: 0px 10px 20px #808080;
      -webkit-box-shadow: 0px 10px 20px #808080;
      -moz-box-shadow: 0px 10px 20px #808080;
      -khtml-box-shadow: 0px 10px 20px #808080;
      filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')
    }

    .MathJax_MenuItem {
      padding: 2px 2em;
      background: transparent
    }

    .MathJax_MenuArrow {
      position: absolute;
      right: .5em;
      padding-top: .25em;
      color: #666666;
      font-size: .75em
    }

    .MathJax_MenuActive .MathJax_MenuArrow {
      color: white
    }

    .MathJax_MenuArrow.RTL {
      left: .5em;
      right: auto
    }

    .MathJax_MenuCheck {
      position: absolute;
      left: .7em
    }

    .MathJax_MenuCheck.RTL {
      right: .7em;
      left: auto
    }

    .MathJax_MenuRadioCheck {
      position: absolute;
      left: 1em
    }

    .MathJax_MenuRadioCheck.RTL {
      right: 1em;
      left: auto
    }

    .MathJax_MenuLabel {
      padding: 2px 2em 4px 1.33em;
      font-style: italic
    }

    .MathJax_MenuRule {
      border-top: 1px solid #CCCCCC;
      margin: 4px 1px 0px
    }

    .MathJax_MenuDisabled {
      color: GrayText
    }

    .MathJax_MenuActive {
      background-color: Highlight;
      color: HighlightText
    }

    .MathJax_MenuDisabled:focus,
    .MathJax_MenuLabel:focus {
      background-color: #E8E8E8
    }

    .MathJax_ContextMenu:focus {
      outline: none
    }

    .MathJax_ContextMenu .MathJax_MenuItem:focus {
      outline: none
    }

    #MathJax_AboutClose {
      top: .2em;
      right: .2em
    }

    .MathJax_Menu .MathJax_MenuClose {
      top: -10px;
      left: -10px
    }

    .MathJax_MenuClose {
      position: absolute;
      cursor: pointer;
      display: inline-block;
      border: 2px solid #AAA;
      border-radius: 18px;
      -webkit-border-radius: 18px;
      -moz-border-radius: 18px;
      -khtml-border-radius: 18px;
      font-family: 'Courier New', Courier;
      font-size: 24px;
      color: #F0F0F0
    }

    .MathJax_MenuClose span {
      display: block;
      background-color: #AAA;
      border: 1.5px solid;
      border-radius: 18px;
      -webkit-border-radius: 18px;
      -moz-border-radius: 18px;
      -khtml-border-radius: 18px;
      line-height: 0;
      padding: 8px 0 6px
    }

    .MathJax_MenuClose:hover {
      color: white !important;
      border: 2px solid #CCC !important
    }

    .MathJax_MenuClose:hover span {
      background-color: #CCC !important
    }

    .MathJax_MenuClose:hover:focus {
      outline: none
    }
  </style>
  <style type="text/css">
    .MathJax_Preview .MJXf-math {
      color: inherit !important
    }
  </style>
  <style type="text/css">
    .MJX_Assistive_MathML {
      position: absolute !important;
      top: 0;
      left: 0;
      clip: rect(1px, 1px, 1px, 1px);
      padding: 1px 0 0 0 !important;
      border: 0 !important;
      height: 1px !important;
      width: 1px !important;
      overflow: hidden !important;
      display: block !important;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none
    }

    .MJX_Assistive_MathML.MJX_Assistive_MathML_Block {
      width: 100% !important
    }
  </style>
  <style type="text/css">
    #MathJax_Zoom {
      position: absolute;
      background-color: #F0F0F0;
      overflow: auto;
      display: block;
      z-index: 301;
      padding: .5em;
      border: 1px solid black;
      margin: 0;
      font-weight: normal;
      font-style: normal;
      text-align: left;
      text-indent: 0;
      text-transform: none;
      line-height: normal;
      letter-spacing: normal;
      word-spacing: normal;
      word-wrap: normal;
      white-space: nowrap;
      float: none;
      -webkit-box-sizing: content-box;
      -moz-box-sizing: content-box;
      box-sizing: content-box;
      box-shadow: 5px 5px 15px #AAAAAA;
      -webkit-box-shadow: 5px 5px 15px #AAAAAA;
      -moz-box-shadow: 5px 5px 15px #AAAAAA;
      -khtml-box-shadow: 5px 5px 15px #AAAAAA;
      filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')
    }

    #MathJax_ZoomOverlay {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 300;
      display: inline-block;
      width: 100%;
      height: 100%;
      border: 0;
      padding: 0;
      margin: 0;
      background-color: white;
      opacity: 0;
      filter: alpha(opacity=0)
    }

    #MathJax_ZoomFrame {
      position: relative;
      display: inline-block;
      height: 0;
      width: 0
    }

    #MathJax_ZoomEventTrap {
      position: absolute;
      left: 0;
      top: 0;
      z-index: 302;
      display: inline-block;
      border: 0;
      padding: 0;
      margin: 0;
      background-color: white;
      opacity: 0;
      filter: alpha(opacity=0)
    }
  </style>
  <style type="text/css">
    .MathJax_Preview {
      color: #888
    }

    #MathJax_Message {
      position: fixed;
      left: 1px;
      bottom: 2px;
      background-color: #E6E6E6;
      border: 1px solid #959595;
      margin: 0px;
      padding: 2px 8px;
      z-index: 102;
      color: black;
      font-size: 80%;
      width: auto;
      white-space: nowrap
    }

    #MathJax_MSIE_Frame {
      position: absolute;
      top: 0;
      left: 0;
      width: 0px;
      z-index: 101;
      border: 0px;
      margin: 0px;
      padding: 0px
    }

    .MathJax_Error {
      color: #CC0000;
      font-style: italic
    }
  </style>
  <style type="text/css">
    .MJXp-script {
      font-size: .8em
    }

    .MJXp-right {
      -webkit-transform-origin: right;
      -moz-transform-origin: right;
      -ms-transform-origin: right;
      -o-transform-origin: right;
      transform-origin: right
    }

    .MJXp-bold {
      font-weight: bold
    }

    .MJXp-italic {
      font-style: italic
    }

    .MJXp-scr {
      font-family: MathJax_Script, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-frak {
      font-family: MathJax_Fraktur, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-sf {
      font-family: MathJax_SansSerif, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-cal {
      font-family: MathJax_Caligraphic, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-mono {
      font-family: MathJax_Typewriter, 'Times New Roman', Times, STIXGeneral, serif
    }

    .MJXp-largeop {
      font-size: 150%
    }

    .MJXp-largeop.MJXp-int {
      vertical-align: -.2em
    }

    .MJXp-math {
      display: inline-block;
      line-height: 1.2;
      text-indent: 0;
      font-family: 'Times New Roman', Times, STIXGeneral, serif;
      white-space: nowrap;
      border-collapse: collapse
    }

    .MJXp-display {
      display: block;
      text-align: center;
      margin: 1em 0
    }

    .MJXp-math span {
      display: inline-block
    }

    .MJXp-box {
      display: block !important;
      text-align: center
    }

    .MJXp-box:after {
      content: " "
    }

    .MJXp-rule {
      display: block !important;
      margin-top: .1em
    }

    .MJXp-char {
      display: block !important
    }

    .MJXp-mo {
      margin: 0 .15em
    }

    .MJXp-mfrac {
      margin: 0 .125em;
      vertical-align: .25em
    }

    .MJXp-denom {
      display: inline-table !important;
      width: 100%
    }

    .MJXp-denom>* {
      display: table-row !important
    }

    .MJXp-surd {
      vertical-align: top
    }

    .MJXp-surd>* {
      display: block !important
    }

    .MJXp-script-box>* {
      display: table !important;
      height: 50%
    }

    .MJXp-script-box>*>* {
      display: table-cell !important;
      vertical-align: top
    }

    .MJXp-script-box>*:last-child>* {
      vertical-align: bottom
    }

    .MJXp-script-box>*>*>* {
      display: block !important
    }

    .MJXp-mphantom {
      visibility: hidden
    }

    .MJXp-munderover {
      display: inline-table !important
    }

    .MJXp-over {
      display: inline-block !important;
      text-align: center
    }

    .MJXp-over>* {
      display: block !important
    }

    .MJXp-munderover>* {
      display: table-row !important
    }

    .MJXp-mtable {
      vertical-align: .25em;
      margin: 0 .125em
    }

    .MJXp-mtable>* {
      display: inline-table !important;
      vertical-align: middle
    }

    .MJXp-mtr {
      display: table-row !important
    }

    .MJXp-mtd {
      display: table-cell !important;
      text-align: center;
      padding: .5em 0 0 .5em
    }

    .MJXp-mtr>.MJXp-mtd:first-child {
      padding-left: 0
    }

    .MJXp-mtr:first-child>.MJXp-mtd {
      padding-top: 0
    }

    .MJXp-mlabeledtr {
      display: table-row !important
    }

    .MJXp-mlabeledtr>.MJXp-mtd:first-child {
      padding-left: 0
    }

    .MJXp-mlabeledtr:first-child>.MJXp-mtd {
      padding-top: 0
    }

    .MJXp-merror {
      background-color: #FFFF88;
      color: #CC0000;
      border: 1px solid #CC0000;
      padding: 1px 3px;
      font-style: normal;
      font-size: 90%
    }

    .MJXp-scale0 {
      -webkit-transform: scaleX(.0);
      -moz-transform: scaleX(.0);
      -ms-transform: scaleX(.0);
      -o-transform: scaleX(.0);
      transform: scaleX(.0)
    }

    .MJXp-scale1 {
      -webkit-transform: scaleX(.1);
      -moz-transform: scaleX(.1);
      -ms-transform: scaleX(.1);
      -o-transform: scaleX(.1);
      transform: scaleX(.1)
    }

    .MJXp-scale2 {
      -webkit-transform: scaleX(.2);
      -moz-transform: scaleX(.2);
      -ms-transform: scaleX(.2);
      -o-transform: scaleX(.2);
      transform: scaleX(.2)
    }

    .MJXp-scale3 {
      -webkit-transform: scaleX(.3);
      -moz-transform: scaleX(.3);
      -ms-transform: scaleX(.3);
      -o-transform: scaleX(.3);
      transform: scaleX(.3)
    }

    .MJXp-scale4 {
      -webkit-transform: scaleX(.4);
      -moz-transform: scaleX(.4);
      -ms-transform: scaleX(.4);
      -o-transform: scaleX(.4);
      transform: scaleX(.4)
    }

    .MJXp-scale5 {
      -webkit-transform: scaleX(.5);
      -moz-transform: scaleX(.5);
      -ms-transform: scaleX(.5);
      -o-transform: scaleX(.5);
      transform: scaleX(.5)
    }

    .MJXp-scale6 {
      -webkit-transform: scaleX(.6);
      -moz-transform: scaleX(.6);
      -ms-transform: scaleX(.6);
      -o-transform: scaleX(.6);
      transform: scaleX(.6)
    }

    .MJXp-scale7 {
      -webkit-transform: scaleX(.7);
      -moz-transform: scaleX(.7);
      -ms-transform: scaleX(.7);
      -o-transform: scaleX(.7);
      transform: scaleX(.7)
    }

    .MJXp-scale8 {
      -webkit-transform: scaleX(.8);
      -moz-transform: scaleX(.8);
      -ms-transform: scaleX(.8);
      -o-transform: scaleX(.8);
      transform: scaleX(.8)
    }

    .MJXp-scale9 {
      -webkit-transform: scaleX(.9);
      -moz-transform: scaleX(.9);
      -ms-transform: scaleX(.9);
      -o-transform: scaleX(.9);
      transform: scaleX(.9)
    }

    .MathJax_PHTML .noError {
      font-size: 90%;
      text-align: left;
      color: black;
      padding: 1px 3px;
      border: 1px solid
    }
  </style>
  <style type="text/css">
    .qc-cmp-button.qc-cmp-secondary-button:hover {
      background-color: #368bd6 !important;
      border-color: transparent !important;
    }

    .qc-cmp-button.qc-cmp-secondary-button:hover {
      color: #ffffff !important;
    }

    .qc-cmp-button.qc-cmp-secondary-button {
      color: #368bd6 !important;
    }

    .qc-cmp-button.qc-cmp-secondary-button {
      background-color: #eee !important;
      border-color: transparent !important;
    }
  </style>
  <link rel="prefetch" as="style"
    href="LearnOpenGL%20-%20Hello%20Triangle_files/a_data_006/lounge.973e8258c48717b79b37fecbf85dcea2.css">
  <link rel="prefetch" as="script"
    href="LearnOpenGL%20-%20Hello%20Triangle_files/a_data_006/common.bundle.78f08d08ee97a04dc049cbcf3a5ec827.js">
  <link rel="prefetch" as="script"
    href="LearnOpenGL%20-%20Hello%20Triangle_files/a_data_006/lounge.bundle.80bb1523f48c6d611d4ba6c652892c20.js">
  <link rel="prefetch" as="script" href="LearnOpenGL%20-%20Hello%20Triangle_files/a_data_006/config.js"><iframe
    style="display: none;" name="cnftComm"></iframe>
  <meta http-equiv="origin-trial"
    content="Az6AfRvI8mo7yiW5fLfj04W21t0ig6aMsGYpIqMTaX60H+b0DkO1uDr+7BrzMcimWzv/X7SXR8jI+uvbV0IJlwYAAACFeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ==">
  <meta http-equiv="origin-trial"
    content="A+USTya+tNvDPaxUgJooz+LaVk5hPoAxpLvSxjogX4Mk8awCTQ9iop6zJ9d5ldgU7WmHqBlnQB41LHHRFxoaBwoAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ==">
  <meta http-equiv="origin-trial"
    content="A7FovoGr67TUBYbnY+Z0IKoJbbmRmB8fCyirUGHavNDtD91CiGyHHSA2hDG9r9T3NjUKFi6egL3RbgTwhhcVDwUAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ==">
  <script src="LearnOpenGL%20-%20Hello%20Triangle_files/pubads_impl_2023011206.js" async=""></script>
  <link rel="preload" href="LearnOpenGL%20-%20Hello%20Triangle_files/f.txt" as="script">
  <script type="text/javascript" src="LearnOpenGL%20-%20Hello%20Triangle_files/f.txt"></script>
</head>

<body>
  <div id="MathJax_Message" style="display: none;"></div>
  <a href="https://learnopengl.com/">
    <div id="header">
    </div>
  </a>

  <div id="supercontainer">
    <!-- 728x90/320x50 -->
    <div id="header_ad">
      <div id="waldo-tag-6194" class="waldo-display-unit" style="min-width: 728px; min-height: 90px;"
        data-processed="true" data-google-query-id="CIO-_qmDy_wCFazIFgUde4AHbQ">
        <div id="google_ads_iframe_/124067137,22550200400/learnopengl728x90FS_2_0__container__"
          style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137,22550200400/learnopengl728x90FS_2_0"
            name="google_ads_iframe_/124067137,22550200400/learnopengl728x90FS_2_0" title="3rd party ad content"
            scrolling="no" marginwidth="0" marginheight="0" style="border: 0px none; vertical-align: bottom;"
            role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="6" data-load-complete="true"
            width="728" height="90" frameborder="0"></iframe></div>
      </div>
    </div>
    <div id="rightad_container" style="height: 17150px;">
      <div id="rightad">
        <div id="waldo-tag-1715" class="waldo-display-unit" style="min-width: 300px; min-height: 600px;"
          data-processed="true" data-google-query-id="CP-9_qmDy_wCFazIFgUde4AHbQ">
          <div id="google_ads_iframe_/124067137,22550200400/learnopengl300x250FL_1_0__container__"
            style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137,22550200400/learnopengl300x250FL_1_0"
              name="google_ads_iframe_/124067137,22550200400/learnopengl300x250FL_1_0" title="3rd party ad content"
              scrolling="no" marginwidth="0" marginheight="0" style="border: 0px none; vertical-align: bottom;"
              role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="2"
              data-load-complete="true" width="300" height="250" frameborder="0"></iframe></div>
        </div>
      </div>

      <div id="admessage">
        If you're running AdBlock, please consider whitelisting this
        site if you'd like to support LearnOpenGL; and no worries, I won't be
        mad if you don't :)
      </div>

      <div id="rightonethirdad" style="display: block; top: 4572.67px;">
        <div id="waldo-tag-2246" class="waldo-display-unit" style="min-width: 300px; min-height: 600px;"
          data-processed="true" data-google-query-id="CIG-_qmDy_wCFazIFgUde4AHbQ">
          <div id="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_2_0__container__"
            style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_2_0"
              name="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_2_0" title="3rd party ad content"
              scrolling="no" marginwidth="0" marginheight="0" style="border: 0px none; vertical-align: bottom;"
              role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="4"
              data-load-complete="true" width="300" height="250" frameborder="0"></iframe></div>
        </div>
      </div>

      <div id="rightbottomad" style="display: block;">
        <div id="waldo-tag-2247" class="waldo-display-unit" style="min-width: 300px; min-height: 600px;"
          data-processed="true" data-google-query-id="CIK-_qmDy_wCFazIFgUde4AHbQ">
          <div id="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_3_0__container__"
            style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_3_0"
              name="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_3_0" title="3rd party ad content"
              scrolling="no" marginwidth="0" marginheight="0" style="border: 0px none; vertical-align: bottom;"
              role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="5"
              data-load-complete="true" width="300" height="250" frameborder="0"></iframe></div>
        </div>
      </div>
    </div>
    <div id="container">
      <div id="loading"></div>
      <script>
        $(document).ready(function () {
          $('#menu-item4').mousedown(function () { MenuClick(4, true) });
          $('#menu-item48').mousedown(function () { MenuClick(48, true) });
          $('#menu-item56').mousedown(function () { MenuClick(56, true) });
          $('#menu-item63').mousedown(function () { MenuClick(63, true) });
          $('#menu-item100').mousedown(function () { MenuClick(100, true) });
          $('#menu-item102').mousedown(function () { MenuClick(102, true) });
          $('#menu-item113').mousedown(function () { MenuClick(113, true) });
          $('#menu-item116').mousedown(function () { MenuClick(116, true) });
          $('#menu-item78').mousedown(function () { MenuClick(78, true) });
          $('#menu-item81').mousedown(function () { MenuClick(81, true) });
          $('#menu-item85').mousedown(function () { MenuClick(85, true) });
          $('#menu-item125').mousedown(function () { MenuClick(125, true) });
          $('#menu-item128').mousedown(function () { MenuClick(128, true) });
          $('#menu-item129').mousedown(function () { MenuClick(129, true) });
          $('#menu-item133').mousedown(function () { MenuClick(133, true) });
          $('#menu-item134').mousedown(function () { MenuClick(134, true) });
          $('#menu-item138').mousedown(function () { MenuClick(138, true) });
          $('#menu-item142').mousedown(function () { MenuClick(142, true) });
          $('#menu-item143').mousedown(function () { MenuClick(143, true) });
        }); 
      </script><iframe src="LearnOpenGL%20-%20Hello%20Triangle_files/container.html"
        style="visibility: hidden; display: none;"></iframe>
      <div id="nav" style="height: 17150px;">
        <div id="social">
          <a href="https://github.com/JoeyDeVries/LearnOpenGL" target="_blank">
            <img src="LearnOpenGL%20-%20Hello%20Triangle_files/github.png" class="social_ico">
          </a>
          <!-- <a href="https://www.facebook.com/Learnopengl-2199631333595544/" target="_blank">
                <img src="/img/facebook.png" class="social_ico">
            </a>-->
          <a href="https://twitter.com/JoeyDeVriez" target="_blank">
            <img src="LearnOpenGL%20-%20Hello%20Triangle_files/twitter.png" class="social_ico">
          </a>

        </div>
        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/nav-button_bottom-arrow.png" style="display: none">
        <ol>
          <li id="Introduction"><a id="menu-item1" href="https://learnopengl.com/Introduction">Introduction </a></li>
          <li id="Getting-started"><span id="menu-item4" class="open">Getting started </span>
            <ol id="menu-items-of4" style="">
              <li id="Getting-started/OpenGL"><a id="menu-item49"
                  href="https://learnopengl.com/Getting-started/OpenGL">OpenGL </a></li>
              <li id="Getting-started/Creating-a-window"><a id="menu-item5"
                  href="https://learnopengl.com/Getting-started/Creating-a-window">Creating a window </a></li>
              <li id="Getting-started/Hello-Window"><a id="menu-item6"
                  href="https://learnopengl.com/Getting-started/Hello-Window">Hello Window </a></li>
              <li id="Getting-started/Hello-Triangle"><a id="menu-item38"
                  href="https://learnopengl.com/Getting-started/Hello-Triangle" class="selected">Hello Triangle </a>
              </li>
              <li id="Getting-started/Shaders"><a id="menu-item39"
                  href="https://learnopengl.com/Getting-started/Shaders">Shaders </a></li>
              <li id="Getting-started/Textures"><a id="menu-item40"
                  href="https://learnopengl.com/Getting-started/Textures">Textures </a></li>
              <li id="Getting-started/Transformations"><a id="menu-item43"
                  href="https://learnopengl.com/Getting-started/Transformations">Transformations </a></li>
              <li id="Getting-started/Coordinate-Systems"><a id="menu-item44"
                  href="https://learnopengl.com/Getting-started/Coordinate-Systems">Coordinate Systems </a></li>
              <li id="Getting-started/Camera"><a id="menu-item47"
                  href="https://learnopengl.com/Getting-started/Camera">Camera </a></li>
              <li id="Getting-started/Review"><a id="menu-item50"
                  href="https://learnopengl.com/Getting-started/Review">Review </a></li>
            </ol>
          </li>
          <li id="Lighting"><span id="menu-item48" class="closed">Lighting </span>
            <ol id="menu-items-of48" style="display:none;">
              <li id="Lighting/Colors"><a id="menu-item51" href="https://learnopengl.com/Lighting/Colors">Colors </a>
              </li>
              <li id="Lighting/Basic-Lighting"><a id="menu-item52"
                  href="https://learnopengl.com/Lighting/Basic-Lighting">Basic Lighting </a></li>
              <li id="Lighting/Materials"><a id="menu-item53"
                  href="https://learnopengl.com/Lighting/Materials">Materials </a></li>
              <li id="Lighting/Lighting-maps"><a id="menu-item54"
                  href="https://learnopengl.com/Lighting/Lighting-maps">Lighting maps </a></li>
              <li id="Lighting/Light-casters"><a id="menu-item55"
                  href="https://learnopengl.com/Lighting/Light-casters">Light casters </a></li>
              <li id="Lighting/Multiple-lights"><a id="menu-item58"
                  href="https://learnopengl.com/Lighting/Multiple-lights">Multiple lights </a></li>
              <li id="Lighting/Review"><a id="menu-item57" href="https://learnopengl.com/Lighting/Review">Review </a>
              </li>
            </ol>
          </li>
          <li id="Model-Loading"><span id="menu-item56" class="closed">Model Loading </span>
            <ol id="menu-items-of56" style="display:none;">
              <li id="Model-Loading/Assimp"><a id="menu-item59"
                  href="https://learnopengl.com/Model-Loading/Assimp">Assimp </a></li>
              <li id="Model-Loading/Mesh"><a id="menu-item60" href="https://learnopengl.com/Model-Loading/Mesh">Mesh
                </a></li>
              <li id="Model-Loading/Model"><a id="menu-item61" href="https://learnopengl.com/Model-Loading/Model">Model
                </a></li>
            </ol>
          </li>
          <li id="Advanced-OpenGL"><span id="menu-item63" class="closed">Advanced OpenGL </span>
            <ol id="menu-items-of63" style="display:none;">
              <li id="Advanced-OpenGL/Depth-testing"><a id="menu-item72"
                  href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">Depth testing </a></li>
              <li id="Advanced-OpenGL/Stencil-testing"><a id="menu-item73"
                  href="https://learnopengl.com/Advanced-OpenGL/Stencil-testing">Stencil testing </a></li>
              <li id="Advanced-OpenGL/Blending"><a id="menu-item74"
                  href="https://learnopengl.com/Advanced-OpenGL/Blending">Blending </a></li>
              <li id="Advanced-OpenGL/Face-culling"><a id="menu-item77"
                  href="https://learnopengl.com/Advanced-OpenGL/Face-culling">Face culling </a></li>
              <li id="Advanced-OpenGL/Framebuffers"><a id="menu-item65"
                  href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">Framebuffers </a></li>
              <li id="Advanced-OpenGL/Cubemaps"><a id="menu-item66"
                  href="https://learnopengl.com/Advanced-OpenGL/Cubemaps">Cubemaps </a></li>
              <li id="Advanced-OpenGL/Advanced-Data"><a id="menu-item69"
                  href="https://learnopengl.com/Advanced-OpenGL/Advanced-Data">Advanced Data </a></li>
              <li id="Advanced-OpenGL/Advanced-GLSL"><a id="menu-item67"
                  href="https://learnopengl.com/Advanced-OpenGL/Advanced-GLSL">Advanced GLSL </a></li>
              <li id="Advanced-OpenGL/Geometry-Shader"><a id="menu-item68"
                  href="https://learnopengl.com/Advanced-OpenGL/Geometry-Shader">Geometry Shader </a></li>
              <li id="Advanced-OpenGL/Instancing"><a id="menu-item70"
                  href="https://learnopengl.com/Advanced-OpenGL/Instancing">Instancing </a></li>
              <li id="Advanced-OpenGL/Anti-Aliasing"><a id="menu-item75"
                  href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">Anti Aliasing </a></li>
            </ol>
          </li>
          <li id="Advanced-Lighting"><span id="menu-item100" class="closed">Advanced Lighting </span>
            <ol id="menu-items-of100" style="display:none;">
              <li id="Advanced-Lighting/Advanced-Lighting"><a id="menu-item101"
                  href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">Advanced Lighting </a></li>
              <li id="Advanced-Lighting/Gamma-Correction"><a id="menu-item110"
                  href="https://learnopengl.com/Advanced-Lighting/Gamma-Correction">Gamma Correction </a></li>
              <li id="Advanced-Lighting/Shadows"><span id="menu-item102" class="closed">Shadows </span>
                <ol id="menu-items-of102" style="display:none;">
                  <li id="Advanced-Lighting/Shadows/Shadow-Mapping"><a id="menu-item103"
                      href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping">Shadow Mapping </a></li>
                  <li id="Advanced-Lighting/Shadows/Point-Shadows"><a id="menu-item104"
                      href="https://learnopengl.com/Advanced-Lighting/Shadows/Point-Shadows">Point Shadows </a></li>
                </ol>
              </li>
              <li id="Advanced-Lighting/Normal-Mapping"><a id="menu-item106"
                  href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">Normal Mapping </a></li>
              <li id="Advanced-Lighting/Parallax-Mapping"><a id="menu-item107"
                  href="https://learnopengl.com/Advanced-Lighting/Parallax-Mapping">Parallax Mapping </a></li>
              <li id="Advanced-Lighting/HDR"><a id="menu-item111"
                  href="https://learnopengl.com/Advanced-Lighting/HDR">HDR </a></li>
              <li id="Advanced-Lighting/Bloom"><a id="menu-item112"
                  href="https://learnopengl.com/Advanced-Lighting/Bloom">Bloom </a></li>
              <li id="Advanced-Lighting/Deferred-Shading"><a id="menu-item108"
                  href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Deferred Shading </a></li>
              <li id="Advanced-Lighting/SSAO"><a id="menu-item109"
                  href="https://learnopengl.com/Advanced-Lighting/SSAO">SSAO </a></li>
            </ol>
          </li>
          <li id="PBR"><span id="menu-item113" class="closed">PBR </span>
            <ol id="menu-items-of113" style="display:none;">
              <li id="PBR/Theory"><a id="menu-item114" href="https://learnopengl.com/PBR/Theory">Theory </a></li>
              <li id="PBR/Lighting"><a id="menu-item115" href="https://learnopengl.com/PBR/Lighting">Lighting </a></li>
              <li id="PBR/IBL"><span id="menu-item116" class="closed">IBL </span>
                <ol id="menu-items-of116" style="display:none;">
                  <li id="PBR/IBL/Diffuse-irradiance"><a id="menu-item117"
                      href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">Diffuse irradiance </a></li>
                  <li id="PBR/IBL/Specular-IBL"><a id="menu-item118"
                      href="https://learnopengl.com/PBR/IBL/Specular-IBL">Specular IBL </a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li id="In-Practice"><span id="menu-item78" class="closed">In Practice </span>
            <ol id="menu-items-of78" style="display:none;">
              <li id="In-Practice/Debugging"><a id="menu-item79"
                  href="https://learnopengl.com/In-Practice/Debugging">Debugging </a></li>
              <li id="In-Practice/Text-Rendering"><a id="menu-item80"
                  href="https://learnopengl.com/In-Practice/Text-Rendering">Text Rendering </a></li>
              <li id="In-Practice/2D-Game"><span id="menu-item81" class="closed">2D Game </span>
                <ol id="menu-items-of81" style="display:none;">
                  <li id="In-Practice/2D-Game/Breakout"><a id="menu-item82"
                      href="https://learnopengl.com/In-Practice/2D-Game/Breakout">Breakout </a></li>
                  <li id="In-Practice/2D-Game/Setting-up"><a id="menu-item88"
                      href="https://learnopengl.com/In-Practice/2D-Game/Setting-up">Setting up </a></li>
                  <li id="In-Practice/2D-Game/Rendering-Sprites"><a id="menu-item83"
                      href="https://learnopengl.com/In-Practice/2D-Game/Rendering-Sprites">Rendering Sprites </a></li>
                  <li id="In-Practice/2D-Game/Levels"><a id="menu-item84"
                      href="https://learnopengl.com/In-Practice/2D-Game/Levels">Levels </a></li>
                  <li id="In-Practice/2D-Game/Collisions"><span id="menu-item85" class="closed">Collisions </span>
                    <ol id="menu-items-of85" style="display:none;">
                      <li id="In-Practice/2D-Game/Collisions/Ball"><a id="menu-item95"
                          href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Ball">Ball </a></li>
                      <li id="In-Practice/2D-Game/Collisions/Collision-detection"><a id="menu-item96"
                          href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection">Collision
                          detection </a></li>
                      <li id="In-Practice/2D-Game/Collisions/Collision-resolution"><a id="menu-item97"
                          href="https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-resolution">Collision
                          resolution </a></li>
                    </ol>
                  </li>
                  <li id="In-Practice/2D-Game/Particles"><a id="menu-item89"
                      href="https://learnopengl.com/In-Practice/2D-Game/Particles">Particles </a></li>
                  <li id="In-Practice/2D-Game/Postprocessing"><a id="menu-item90"
                      href="https://learnopengl.com/In-Practice/2D-Game/Postprocessing">Postprocessing </a></li>
                  <li id="In-Practice/2D-Game/Powerups"><a id="menu-item91"
                      href="https://learnopengl.com/In-Practice/2D-Game/Powerups">Powerups </a></li>
                  <li id="In-Practice/2D-Game/Audio"><a id="menu-item94"
                      href="https://learnopengl.com/In-Practice/2D-Game/Audio">Audio </a></li>
                  <li id="In-Practice/2D-Game/Render-text"><a id="menu-item92"
                      href="https://learnopengl.com/In-Practice/2D-Game/Render-text">Render text </a></li>
                  <li id="In-Practice/2D-Game/Final-thoughts"><a id="menu-item93"
                      href="https://learnopengl.com/In-Practice/2D-Game/Final-thoughts">Final thoughts </a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li id="Guest-Articles"><span id="menu-item125" class="closed">Guest Articles </span>
            <ol id="menu-items-of125" style="display:none;">
              <li id="Guest-Articles/How-to-publish"><a id="menu-item126"
                  href="https://learnopengl.com/Guest-Articles/How-to-publish">How to publish </a></li>
              <li id="Guest-Articles/2020"><span id="menu-item128" class="closed">2020 </span>
                <ol id="menu-items-of128" style="display:none;">
                  <li id="Guest-Articles/2020/OIT"><span id="menu-item129" class="closed">OIT </span>
                    <ol id="menu-items-of129" style="display:none;">
                      <li id="Guest-Articles/2020/OIT/Introduction"><a id="menu-item130"
                          href="https://learnopengl.com/Guest-Articles/2020/OIT/Introduction">Introduction </a></li>
                      <li id="Guest-Articles/2020/OIT/Weighted-Blended"><a id="menu-item132"
                          href="https://learnopengl.com/Guest-Articles/2020/OIT/Weighted-Blended">Weighted Blended </a>
                      </li>
                    </ol>
                  </li>
                  <li id="Guest-Articles/2020/Skeletal-Animation"><a id="menu-item131"
                      href="https://learnopengl.com/Guest-Articles/2020/Skeletal-Animation">Skeletal Animation </a></li>
                </ol>
              </li>
              <li id="Guest-Articles/2021"><span id="menu-item133" class="closed">2021 </span>
                <ol id="menu-items-of133" style="display:none;">
                  <li id="Guest-Articles/2021/CSM"><a id="menu-item137"
                      href="https://learnopengl.com/Guest-Articles/2021/CSM">CSM </a></li>
                  <li id="Guest-Articles/2021/Scene"><span id="menu-item134" class="closed">Scene </span>
                    <ol id="menu-items-of134" style="display:none;">
                      <li id="Guest-Articles/2021/Scene/Scene-Graph"><a id="menu-item135"
                          href="https://learnopengl.com/Guest-Articles/2021/Scene/Scene-Graph">Scene Graph </a></li>
                      <li id="Guest-Articles/2021/Scene/Frustum-Culling"><a id="menu-item136"
                          href="https://learnopengl.com/Guest-Articles/2021/Scene/Frustum-Culling">Frustum Culling </a>
                      </li>
                    </ol>
                  </li>
                  <li id="Guest-Articles/2021/Tessellation"><span id="menu-item138" class="closed">Tessellation </span>
                    <ol id="menu-items-of138" style="display:none;">
                      <li id="Guest-Articles/2021/Tessellation/Height-map"><a id="menu-item139"
                          href="https://learnopengl.com/Guest-Articles/2021/Tessellation/Height-map">Height map </a>
                      </li>
                      <li id="Guest-Articles/2021/Tessellation/Tessellation"><a id="menu-item140"
                          href="https://learnopengl.com/Guest-Articles/2021/Tessellation/Tessellation">Tessellation </a>
                      </li>
                    </ol>
                  </li>
                  <li id="Guest-Articles/2021/DSA"><a id="menu-item141"
                      href="https://learnopengl.com/Guest-Articles/2021/DSA">DSA </a></li>
                </ol>
              </li>
              <li id="Guest-Articles/2022"><span id="menu-item142" class="closed">2022 </span>
                <ol id="menu-items-of142" style="display:none;">
                  <li id="Guest-Articles/2022/Compute-Shaders"><span id="menu-item143" class="closed">Compute Shaders
                    </span>
                    <ol id="menu-items-of143" style="display:none;">
                      <li id="Guest-Articles/2022/Compute-Shaders/Introduction"><a id="menu-item144"
                          href="https://learnopengl.com/Guest-Articles/2022/Compute-Shaders/Introduction">Introduction
                        </a></li>
                    </ol>
                  </li>
                  <li id="Guest-Articles/2022/Phys.-Based-Bloom"><a id="menu-item145"
                      href="https://learnopengl.com/Guest-Articles/2022/Phys.-Based-Bloom">Phys. Based Bloom </a></li>
                  <li id="Guest-Articles/2022/Area-Lights"><a id="menu-item146"
                      href="https://learnopengl.com/Guest-Articles/2022/Area-Lights">Area Lights </a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li id="Code-repository"><a id="menu-item99" href="https://learnopengl.com/Code-repository">Code repository
            </a></li>
          <li id="Translations"><a id="menu-item119" href="https://learnopengl.com/Translations">Translations </a></li>
          <li id="About"><a id="menu-item2" href="https://learnopengl.com/About">About </a></li>
        </ol>
        <div id="menu_book">
          <a href="https://geni.us/learnopengl" target="_blank"><img
              src="LearnOpenGL%20-%20Hello%20Triangle_files/below_menu.png" class="clean"></a>
        </div>
        <div id="donate">
          <a href="https://www.paypal.me/learnopengl/" target="_blank">
            <div id="donate_img"></div>
            <img style="display: none" src="LearnOpenGL%20-%20Hello%20Triangle_files/donate_button_hover.png">
            <!--<img id="donate_img" src="img/patreon.png"/>-->
          </a>
          <!--<div id="alipay">
            <img style="width: 150px;" class="clean" src="/img/alipay_logo.png"/>
            <img style="width: 150px; margin-top: 5px" src="/img/alipay.png"/>
          </div>-->
        </div>

        <div class="btc">
          <h3>BTC</h3>
          <p>
            1CLGKgmBSuYJ1nnvDGAepVTKNNDpUjfpRa
          </p>
          <img src="LearnOpenGL%20-%20Hello%20Triangle_files/btc_qr_new.png">
        </div>
        <div class="btc">
          <h3>ETH/ERC20</h3>
          <p>
            0x1de59bd9e52521a46309474f8372531533bd7c43
          </p>
          <img src="LearnOpenGL%20-%20Hello%20Triangle_files/erc20_qr_new.png">
        </div>

        <div id="ad">
          <!--<div id="waldo-tag-1684"></div>-->
        </div>

        <div id="lefttwothirdad" style="display: block; top: 10968.3px;">
          <div id="waldo-tag-2245" class="waldo-display-unit" style="min-width: 300px; min-height: 600px;"
            data-processed="true" data-google-query-id="CIC-_qmDy_wCFazIFgUde4AHbQ">
            <div id="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_1_0__container__"
              style="border: 0pt none;"><iframe id="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_1_0"
                name="google_ads_iframe_/124067137,22550200400/learnopengl300x600FL_1_0" title="3rd party ad content"
                scrolling="no" marginwidth="0" marginheight="0" style="border: 0px none; vertical-align: bottom;"
                role="region" aria-label="Advertisement" tabindex="0" data-google-container-id="3"
                data-load-complete="true" width="300" height="250" frameborder="0"></iframe></div>
          </div>
        </div>
      </div>

      <div id="content">
        <h1 id="content-title">Hello Triangle</h1>
        <h1 id="content-url" style="display:none;">Getting-started/Hello-Triangle</h1>
        <p>
          In OpenGL everything is in 3D space, but the screen or window is a 2D
          array of pixels so a large part of OpenGL's work is about transforming
          all 3D coordinates to 2D pixels that fit on your screen. The process of
          transforming 3D coordinates to 2D pixels is managed by the <def>graphics pipeline</def>
          of OpenGL. The graphics pipeline can be divided into two large parts:
          the first transforms your 3D coordinates into 2D coordinates and the
          second part transforms the 2D coordinates into actual colored pixels. In
          this chapter we'll briefly discuss the graphics pipeline and how we can
          use it to our advantage to create fancy pixels.
        </p>
        <p>
          在 OpenGL 中，一切都在 3D 空间中，但屏幕或窗口是二维像素阵列，因此 OpenGL 的大部分工作是将所有 3D 坐标转换为适合屏幕的二维像素。 将 3D 坐标转换为 2D 像素的过程由 OpenGL
          的图形管道管理。 图形管道可以分为两个大部分：第一部分将 3D 坐标转换为 2D 坐标，第二部分将 2D 坐标转换为实际的彩色像素。 在本章中，我们将简要讨论图形管道以及我们如何利用它来创建精美的像素。
        </p>

        <!--<note>
  There is a difference between a 2D coordinate and a pixel. A 2D coordinate is a very precise representation of where a point is in 2D space, while a 2D pixel is an approximation of that point limited by the resolution of your screen/window.
</note>-->

        <p>
          The graphics pipeline takes as input a set of 3D coordinates and
          transforms these to colored 2D pixels on your screen. The graphics
          pipeline can be divided into several steps where each step requires the
          output of the previous step as its input. All of these steps are highly
          specialized (they have one specific function) and can easily be executed
          in parallel. Because of their parallel nature, graphics cards of today
          have thousands of small processing cores to quickly process your data
          within the graphics pipeline. The processing cores run small programs on
          the GPU for each step of the pipeline. These small programs are called <def>shaders</def>.
        </p>
        <p>图形管道将一组 3D 坐标作为输入，并将它们转换为屏幕上的彩色 2D 像素。 图形流水线可以分为几个步骤，每个步骤都需要前一步的输出作为其输入。
          所有这些步骤都是高度专业化的（它们具有一个特定的功能）并且可以很容易地并行执行。 由于它们的并行特性，当今的图形卡具有数千个小型处理核心，可以在图形管道内快速处理您的数据。 处理核心在 GPU
          上为流水线的每个步骤运行小程序。 这些小程序称为着色器。</p>

        <p>
          Some of these shaders are configurable by the developer which allows
          us to write our own shaders to replace the existing default shaders.
          This gives us much more fine-grained control over specific parts of the
          pipeline and because they run on the GPU, they can also save us valuable
          CPU time. Shaders are written in the <def>OpenGL Shading Language</def> (<def>GLSL</def>) and we'll delve more
          into that in the next chapter.
        </p>
        <p>其中一些着色器可由开发人员配置，这允许我们编写自己的着色器来替换现有的默认着色器。 这使我们能够对管道的特定部分进行更细粒度的控制，并且由于它们在 GPU 上运行，它们还可以为我们节省宝贵的 CPU 时间。 着色器是用
          OpenGL 着色语言 (GLSL) 编写的，我们将在下一章深入研究它。</p>

        <p>
          Below you'll find an abstract representation of all the stages of
          the graphics pipeline. Note that the blue sections represent sections
          where we can inject our own shaders.
        </p>
        <p>您将在下面找到图形管道所有阶段的抽象表示。 请注意，蓝色部分代表我们可以注入自己的着色器的部分。</p>

        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/pipeline.png" class="clean"
          alt="The OpenGL graphics pipeline with shader stages">


        <p>
          As you can see, the graphics pipeline contains a large number of
          sections that each handle one specific part of converting your vertex
          data to a fully rendered pixel. We will briefly explain each part of
          the pipeline in a simplified way to give you a good overview of how the
          pipeline operates.
        </p>
        <p>如您所见，图形管道包含大量部分，每个部分处理将顶点数据转换为完全渲染像素的特定部分。 我们将以简化的方式简要解释管道的每个部分，让您对管道的运行方式有一个很好的了解。</p>

        <p>
          As input to the graphics pipeline we pass in a list of three 3D
          coordinates that should form a triangle in an array here called <code>Vertex Data</code>; this vertex data is
          a collection of vertices. A <def>vertex</def> is a collection of data per 3D coordinate. This vertex's data is
          represented using <def>vertex attributes</def>
          that can contain any data we'd like, but for simplicity's sake let's
          assume that each vertex consists of just a 3D position and some color
          value.
        </p>
        <p>作为图形管道的输入，我们传入一个包含三个 3D 坐标的列表，这些坐标应在此处称为顶点数据的数组中形成一个三角形； 此顶点数据是顶点的集合。 顶点是每个 3D 坐标的数据集合。
          这个顶点的数据使用可以包含我们想要的任何数据的顶点属性来表示，但是为了简单起见，我们假设每个顶点只包含一个 3D 位置和一些颜色值。</p>

        <note>
          In order for OpenGL to know what to make of your collection of
          coordinates and color values OpenGL requires you to hint what kind of
          render types you want to form with the data. Do we want the data
          rendered as a collection of points, a collection of triangles or perhaps
          just one long line? Those hints are called <def>primitives</def> and are given to OpenGL while calling any of
          the drawing commands. Some of these hints are <var>GL_POINTS</var>, <var>GL_TRIANGLES</var> and
          <var>GL_LINE_STRIP</var>.

          <br><br>

          为了让 OpenGL 知道如何处理你的坐标和颜色值集合，OpenGL 需要你暗示你想用数据形成什么样的渲染类型。 我们是否希望将数据呈现为点的集合、三角形的集合或可能只是一条长线？
          这些提示被称为基元，并在调用任何绘图命令时提供给 OpenGL。 其中一些提示是 GL_POINTS、GL_TRIANGLES 和 GL_LINE_STRIP。
        </note>

        <p>
          The first part of the pipeline is the <def>vertex shader</def> that
          takes as input a single vertex. The main purpose of the vertex shader is
          to transform 3D coordinates into different 3D coordinates (more on that
          later) and the vertex shader allows us to do some basic processing on
          the vertex attributes.
        </p>
        <p>管道的第一部分是顶点着色器，它将单个顶点作为输入。 顶点着色器的主要目的是将 3D 坐标转换为不同的 3D 坐标（稍后会详细介绍），顶点着色器允许我们对顶点属性进行一些基本处理。</p>

        <p>
          The <def>primitive assembly</def> stage takes as input all the vertices (or vertex if <var>GL_POINTS</var>
          is chosen) from the vertex shader that form a primitive and assembles
          all the point(s) in the primitive shape given; in this case a triangle.
        </p>
        <p>图元组装阶段将来自顶点着色器的所有顶点（或顶点，如果选择了 GL_POINTS）作为输入，形成一个图元，并在给定的图元形状中组装所有点； 在这种情况下是一个三角形。</p>

        <p>
          The output of the primitive assembly stage is passed to the <def>geometry shader</def>.
          The geometry shader takes as input a collection of vertices that form a
          primitive and has the ability to generate other shapes by emitting new
          vertices to form new (or other) primitive(s). In this example case, it
          generates a second triangle out of the given shape.
        </p>
        <p>图元组装阶段的输出被传递给几何着色器。 几何着色器将形成图元的顶点集合作为输入，并能够通过发射新顶点以形成新的（或其他）图元来生成其他形状。 在这个例子中，它根据给定的形状生成第二个三角形。</p>

        <p>
          The output of the geometry shader is then passed on to the <def>rasterization stage</def>
          where it maps the resulting primitive(s) to the corresponding pixels on
          the final screen, resulting in fragments for the fragment shader to
          use. Before the fragment shaders run, <def>clipping</def> is performed. Clipping discards all fragments that
          are outside your view, increasing performance.
        </p>
        <p>几何着色器的输出然后被传递到光栅化阶段，它将生成的图元映射到最终屏幕上的相应像素，从而产生供片段着色器使用的片段。 在片段着色器运行之前，会执行裁剪。 裁剪会丢弃您视野之外的所有片段，从而提高性能。</p>

        <note>
          A fragment in OpenGL is all the data required for OpenGL to render a single pixel.

          <br><br>
          OpenGL 中的片段是 OpenGL 渲染单个像素所需的所有数据。
        </note>

        <p>
          The main purpose of the <def>fragment shader</def> is to calculate the
          final color of a pixel and this is usually the stage where all the
          advanced OpenGL effects occur. Usually the fragment shader contains data
          about the 3D scene that it can use to calculate the final pixel color
          (like lights, shadows, color of the light and so on).
        </p>
        <p>片段着色器的主要目的是计算像素的最终颜色，这通常是所有高级 OpenGL 效果发生的阶段。 通常片段着色器包含有关 3D 场景的数据，可用于计算最终像素颜色（如灯光、阴影、灯光颜色等）。</p>


        <p>
          After all the corresponding color values have been determined, the
          final object will then pass through one more stage that we call the <def>alpha test</def> and <def>blending
          </def>
          stage. This stage checks the corresponding depth (and stencil) value
          (we'll get to those later) of the fragment and uses those to check if
          the resulting fragment is in front or behind other objects and should be
          discarded accordingly. The stage also checks for <def>alpha</def> values (alpha values define the opacity of
          an object) and <def>blends</def>
          the objects accordingly. So even if a pixel output color is calculated
          in the fragment shader, the final pixel color could still be something
          entirely different when rendering multiple triangles.
        </p>
        <p>在确定了所有相应的颜色值之后，最终对象将再经过一个阶段，我们称之为 alpha 测试和混合阶段。
          此阶段检查片段的相应深度（和模板）值（我们将在稍后讨论）并使用这些值来检查生成的片段是在其他对象的前面还是后面，并应相应地丢弃。 该舞台还检查 alpha 值（alpha 值定义对象的不透明度）并相应地混合对象。
          因此，即使在片段着色器中计算了像素输出颜色，在渲染多个三角形时最终像素颜色仍然可能完全不同。</p>

        <p>
          As you can see, the graphics pipeline is quite a complex whole and
          contains many configurable parts. However, for almost all the cases we
          only have to work with the vertex and fragment shader. The geometry
          shader is optional and usually left to its default shader. There is also
          the tessellation stage and transform feedback loop that we haven't
          depicted here, but that's something for later.
        </p>
        <p>如您所见，图形管道是一个相当复杂的整体，包含许多可配置的部分。 然而，对于几乎所有情况，我们只需要使用顶点和片段着色器。 几何着色器是可选的，通常留给它的默认着色器。
          还有我们在这里没有描述的曲面细分阶段和变换反馈循环，但这是稍后的内容。</p>

        <p>
          In modern OpenGL we are <strong>required</strong> to define at least a
          vertex and fragment shader of our own (there are no default
          vertex/fragment shaders on the GPU). For this reason it is often quite
          difficult to start learning modern OpenGL since a great deal of
          knowledge is required before being able to render your first triangle.
          Once you do get to finally render your triangle at the end of this
          chapter you will end up knowing a lot more about graphics programming.
        </p>
        <p>在现代 OpenGL 中，我们需要至少定义一个我们自己的顶点和片段着色器（GPU 上没有默认的顶点/片段着色器）。 出于这个原因，开始学习现代 OpenGL
          通常非常困难，因为在能够渲染您的第一个三角形之前需要大量的知识。 一旦你在本章结束时最终渲染了你的三角形，你将最终了解更多关于图形编程的知识。</p>

        <h2>Vertex input</h2>
        <p>
          To start drawing something we have to first give OpenGL some input
          vertex data. OpenGL is a 3D graphics library so all coordinates that we
          specify in OpenGL are in 3D (<code>x</code>, <code>y</code> and <code>z</code> coordinate). OpenGL doesn't
          simply transform <strong>all</strong> your 3D coordinates to 2D pixels on your screen; OpenGL only processes
          3D coordinates when they're in a specific range between <code>-1.0</code> and <code>1.0</code> on all 3 axes
          (<code>x</code>, <code>y</code> and <code>z</code>). All coordinates within this so called <def>normalized
            device coordinates</def> range will end up visible on your screen (and all coordinates outside this region
          won't).
        </p>
        <p>要开始绘制某些东西，我们必须首先给 OpenGL 一些输入顶点数据。 OpenGL 是一个 3D 图形库，因此我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x、y 和 z 坐标）。 OpenGL
          不会简单地将所有 3D 坐标转换为屏幕上的 2D 像素； 当 3D 坐标在所有 3 个轴（x、y 和 z）上处于 -1.0 和 1.0 之间的特定范围时，OpenGL 才处理它们。
          这个所谓的标准化设备坐标范围内的所有坐标最终都会在您的屏幕上可见（并且该区域之外的所有坐标都不会）。</p>

        <p>
          Because we want to render a single triangle we want to specify a total
          of three vertices with each vertex having a 3D position. We define them
          in normalized device coordinates (the visible region of OpenGL) in a <code>float</code> array:
        </p>
        <p>因为我们要渲染单个三角形，所以我们要指定总共三个顶点，每个顶点都有一个 3D 位置。 我们将它们定义在一个浮点数组中的规范化设备坐标（OpenGL 的可见区域）中：</p>

        <pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> vertices[] = {
    -<span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,
     <span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,
     <span class="hljs-number">0.0f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>
};  
</code></pre>

        <p>
          Because OpenGL works in 3D space we render a 2D triangle with each vertex having a <code>z</code> coordinate
          of <code>0.0</code>. This way the <em>depth</em> of the triangle remains the same making it look like it's 2D.
        </p>
        <p>因为 OpenGL 在 3D 空间中工作，我们渲染一个 2D 三角形，每个顶点的 z 坐标为 0.0。 这样三角形的深度保持不变，使其看起来像二维的。</p>

        <note>
          <strong>Normalized Device Coordinates (NDC)</strong><br>
          <p>
            Once your vertex coordinates have been processed in the vertex shader, they should be in <def>normalized
              device coordinates</def> which is a small space where the <code>x</code>, <code>y</code> and
            <code>z</code> values vary from <code>-1.0</code> to <code>1.0</code>.
            Any coordinates that fall outside this range will be discarded/clipped
            and won't be visible on your screen. Below you can see the triangle we
            specified within normalized device coordinates (ignoring the <code>z</code> axis):
          </p>
          <p>一旦你的顶点坐标在顶点着色器中被处理，它们应该在规范化的设备坐标中，这是一个小空间，其中 x、y 和 z 值从 -1.0 到 1.0 不等。 超出此范围的任何坐标都将被丢弃/剪裁，并且不会在屏幕上显示。
            下面你可以看到我们在规范化设备坐标中指定的三角形（忽略 z 轴）：</p>
          <img src="LearnOpenGL%20-%20Hello%20Triangle_files/ndc.png" class="clean"
            alt="2D Normalized Device Coordinates as shown in a graph">
          <p>
            Unlike usual screen coordinates the positive y-axis points in the up-direction and the <code>(0,0)</code>
            coordinates are at the center of the graph, instead of top-left.
            Eventually you want all the (transformed) coordinates to end up in this
            coordinate space, otherwise they won't be visible.
          </p>
          <p>与通常的屏幕坐标不同，正 y 轴指向上方向，(0,0) 坐标位于图形的中心，而不是左上角。 最终您希望所有（转换后的）坐标都在此坐标空间中结束，否则它们将不可见。</p>
          <p>
            Your NDC coordinates will then be transformed to <def>screen-space coordinates</def> via the <def>viewport
              transform</def> using the data you provided with <fun>
              <function id="22">glViewport</function>
            </fun>. The resulting screen-space coordinates are then transformed to fragments as inputs to your fragment
            shader.
          </p>
          <p>然后，您的 NDC 坐标将使用您随 glViewport 提供的数据通过视口变换转换为屏幕空间坐标。 然后将生成的屏幕空间坐标转换为片段，作为片段着色器的输入。</p>
        </note>

        <p>
          With the vertex data defined we'd like to send it as input to the
          first process of the graphics pipeline: the vertex shader. This is done
          by creating memory on the GPU where we store the vertex data, configure
          how OpenGL should interpret the memory and specify how to send the data
          to the graphics card. The vertex shader then processes as much vertices
          as we tell it to from its memory.
        </p>
        <p>定义了顶点数据后，我们希望将其作为输入发送到图形管道的第一个进程：顶点着色器。 这是通过在我们存储顶点数据的 GPU 上创建内存、配置 OpenGL 应如何解释内存并指定如何将数据发送到显卡来完成的。
          顶点着色器然后从它的内存中处理我们告诉它的尽可能多的顶点。</p>

        <p>
          We manage this memory via so called <def>vertex buffer objects</def> (<def>VBO</def>)
          that can store a large number of vertices in the GPU's memory. The
          advantage of using those buffer objects is that we can send large
          batches of data all at once to the graphics card, and keep it there if
          there's enough memory left, without having to send data one vertex at a
          time. Sending data to the graphics card from the CPU is relatively slow,
          so wherever we can we try to send as much data as possible at once.
          Once the data is in the graphics card's memory the vertex shader has
          almost instant access to the vertices making it extremely fast
        </p>
        <p>我们通过所谓的顶点缓冲对象 (VBO) 管理此内存，该对象可以在 GPU 的内存中存储大量顶点。
          使用这些缓冲区对象的好处是我们可以一次将大量数据发送到显卡，如果有足够的内存就将其保留在那里，而不必一次发送一个顶点的数据。 从 CPU 向显卡发送数据的速度相对较慢，因此我们尽可能地一次性发送尽可能多的数据。
          一旦数据在显卡的内存中，顶点着色器几乎可以立即访问顶点，从而使其速度非常快</p>

        <p>
          A vertex buffer object is our first occurrence of an OpenGL object as we've discussed in the <a
            href="https://learnopengl.com/Getting-Started/OpenGL" target="_blank">OpenGL</a>
          chapter. Just like any object in OpenGL, this buffer has a unique ID
          corresponding to that buffer, so we can generate one with a buffer ID
          using the <fun>
            <function id="12">glGenBuffers</function>
          </fun> function:
        </p>
        <p>正如我们在 OpenGL 章节中讨论的那样，顶点缓冲对象是我们第一次出现的 OpenGL 对象。 就像 OpenGL 中的任何对象一样，此缓冲区具有与该缓冲区对应的唯一 ID，因此我们可以使用 glGenBuffers
          函数生成具有缓冲区 ID 的对象：</p>

        <pre class="cpp"><code class=" hljs ">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VBO;
<function id="12">glGenBuffers</function>(<span class="hljs-number">1</span>, &amp;VBO);  
</code></pre>

        <p>
          OpenGL has many types of buffer objects and the buffer type of a vertex buffer object is
          <var>GL_ARRAY_BUFFER</var>.
          OpenGL allows us to bind to several buffers at once as long as they
          have a different buffer type. We can bind the newly created buffer to
          the <var>GL_ARRAY_BUFFER</var> target with the <fun>
            <function id="32">glBindBuffer</function>
          </fun> function:
        </p>
        <p>OpenGL有多种类型的缓冲对象，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。 OpenGL 允许我们同时绑定多个缓冲区，只要它们具有不同的缓冲区类型即可。 我们可以使用 glBindBuffer
          函数将新创建的缓冲区绑定到 GL_ARRAY_BUFFER 目标：</p>

        <pre><code class=" hljs ">
<function id="32">glBindBuffer</function>(GL_ARRAY_BUFFER, VBO);  
</code></pre>

        <p>
          From that point on any buffer calls we make (on the <var>GL_ARRAY_BUFFER</var> target) will be used to
          configure the currently bound buffer, which is <var>VBO</var>. Then we can make a call to the
          <fun>
            <function id="31">glBufferData</function>
          </fun> function that copies the previously defined vertex data into the buffer's memory:
        </p>
        <p>从那时起，我们（在 GL_ARRAY_BUFFER 目标上）进行的任何缓冲区调用都将用于配置当前绑定的缓冲区，即 VBO。 然后我们可以调用 glBufferData 函数，将之前定义的顶点数据复制到缓冲区的内存中：
        </p>

        <pre><code class=" hljs cpp">
<function id="31">glBufferData</function>(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);
</code></pre>

        <p>
          <fun>
            <function id="31">glBufferData</function>
          </fun> is a function
          specifically targeted to copy user-defined data into the currently bound
          buffer. Its first argument is the type of the buffer we want to copy
          data into: the vertex buffer object currently bound to the <var>GL_ARRAY_BUFFER</var> target. The second
          argument specifies the size of the data (in bytes) we want to pass to the buffer; a simple <code>sizeof</code>
          of the vertex data suffices. The third parameter is the actual data we want to send.
        </p>
        <p>glBufferData 是一个专门用于将用户定义的数据复制到当前绑定的缓冲区中的函数。 它的第一个参数是我们要将数据复制到的缓冲区的类型：当前绑定到 GL_ARRAY_BUFFER 目标的顶点缓冲区对象。
          第二个参数指定我们要传递给缓冲区的数据的大小（以字节为单位）； 顶点数据的简单 sizeof 就足够了。 第三个参数是我们要发送的实际数据。</p>

        <p>
          The fourth parameter specifies how we want the graphics card to manage the given data. This can take 3 forms:
        </p>
        <p>第四个参数指定我们希望显卡如何管理给定的数据。 这可以采取 3 种形式：</p>

        <ul>
          <li><var>GL_STREAM_DRAW</var>: the data is set only once and used by the GPU at most a few times.
            <br>数据只设置一次，GPU 最多使用几次。
          </li>
          <li><var>GL_STATIC_DRAW</var>: the data is set only once and used many times.
            <br>数据只设置一次，多次使用。
          </li>
          <li><var>GL_DYNAMIC_DRAW</var>: the data is changed a lot and used many times.
            <br>数据变化很大，使用了很多次。
          </li>

        </ul>

        <p>
          The position data of the triangle does not change, is used a lot, and
          stays the same for every render call so its usage type should best be <var>GL_STATIC_DRAW</var>. If, for
          instance, one would have a buffer with data that is likely to change frequently, a usage type of
          <var>GL_DYNAMIC_DRAW</var> ensures the graphics card will place the data in memory that allows for faster
          writes.
        </p>
        <p>
          三角形的位置数据不会改变，被大量使用，并且每次渲染调用都保持不变，所以它的使用类型最好是 GL_STATIC_DRAW。 例如，如果缓冲区中的数据可能会频繁更改，则 GL_DYNAMIC_DRAW
          的使用类型可确保显卡将数据放入内存中，从而实现更快的写入速度。
        </p>
        <p>
          As of now we stored the vertex data within memory on the graphics card as managed by a vertex buffer object
          named <var>VBO</var>. Next we want to create a vertex and fragment shader that actually processes this data,
          so let's start building those.
        </p>
        <p>
          截至目前，我们将顶点数据存储在显卡的内存中，由名为 VBO 的顶点缓冲区对象管理。 接下来我们要创建一个真正处理这些数据的顶点和片段着色器，所以让我们开始构建它们。
        </p>
        <h2>Vertex shader</h2>
        <p>
          The vertex shader is one of the shaders that are programmable by
          people like us. Modern OpenGL requires that we at least set up a vertex
          and fragment shader if we want to do some rendering so we will briefly
          introduce shaders and configure two very simple shaders for drawing our
          first triangle. In the next chapter we'll discuss shaders in more
          detail.
        </p>
        <p>顶点着色器是像我们这样的人可以编程的着色器之一。 如果我们想要进行一些渲染，现代 OpenGL 要求我们至少设置一个顶点和片段着色器，因此我们将简要介绍着色器并配置两个非常简单的着色器来绘制我们的第一个三角形。
          在下一章中，我们将更详细地讨论着色器。</p>

        <p>
          The first thing we need to do is write the vertex shader in the shader
          language GLSL (OpenGL Shading Language) and then compile this shader so
          we can use it in our application. Below you'll find the source code of a
          very basic vertex shader in GLSL:
        </p>
        <p>我们需要做的第一件事是用着色器语言 GLSL（OpenGL 着色语言）编写顶点着色器，然后编译这个着色器，以便我们可以在我们的应用程序中使用它。 下面您将找到 GLSL 中一个非常基本的顶点着色器的源代码：</p>

        <pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">layout</span> (location = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-built_in">vec3</span> aPos;

<span class="hljs-keyword">void</span> main()
{
    gl_Position = <span class="hljs-built_in">vec4</span>(aPos.x, aPos.y, aPos.z, <span class="hljs-number">1.0</span>);
}
</code></pre>

        <p>
          As you can see, GLSL looks similar to C. Each shader begins with a
          declaration of its version. Since OpenGL 3.3 and higher the version
          numbers of GLSL match the version of OpenGL (GLSL version 420
          corresponds to OpenGL version 4.2 for example). We also explicitly
          mention we're using core profile functionality.
        </p>
        <p>如您所见，GLSL 看起来类似于 C。每个着色器都以其版本声明开始。 由于 OpenGL 3.3 及更高版本，GLSL 的版本号与 OpenGL 的版本匹配（例如，GLSL 版本 420 对应于 OpenGL 版本
          4.2）。 我们还明确提到我们正在使用核心配置文件功能。</p>

        <p>
          Next we declare all the input vertex attributes in the vertex shader with the <code>in</code>
          keyword. Right now we only care about position data so we only need a
          single vertex attribute. GLSL has a vector datatype that contains 1 to 4
          floats based on its postfix digit. Since each vertex has a 3D
          coordinate we create a <code>vec3</code> input variable with the name <var>aPos</var>. We also specifically
          set the location of the input variable via <code>layout (location = 0)</code> and you'll later see that why
          we're going to need that location.
        </p>
        <p>接下来，我们使用 in 关键字在顶点着色器中声明所有输入顶点属性。 现在我们只关心位置数据，所以我们只需要一个顶点属性。 GLSL 有一个矢量数据类型，它包含 1 到 4 个基于其后缀数字的浮点数。
          由于每个顶点都有一个 3D 坐标，我们创建一个名为 aPos 的 vec3 输入变量。 我们还通过布局 (location = 0) 专门设置了输入变量的位置，您稍后会看到为什么我们需要该位置。</p>

        <note>
          <strong>Vector</strong><br>
          In graphics programming we use the mathematical concept of a vector
          quite often, since it neatly represents positions/directions in any
          space and has useful mathematical properties. A vector in GLSL has a
          maximum size of 4 and each of its values can be retrieved via <code>vec.x</code>, <code>vec.y</code>,
          <code>vec.z</code> and <code>vec.w</code> respectively where each of them represents a coordinate in space.
          Note that the <code>vec.w</code> component is not used as a position in space (we're dealing with 3D, not 4D)
          but is used for something called <def>perspective division</def>. We'll discuss vectors in much greater depth
          in a later chapter.

          <br><br>
          在图形编程中，我们经常使用矢量的数学概念，因为它巧妙地表示任何空间中的位置/方向，并且具有有用的数学属性。 GLSL 中的向量最大大小为 4，它的每个值都可以分别通过 vec.x、vec.y、vec.z 和 vec.w
          检索，其中每个值代表空间中的一个坐标。 请注意，vec.w 组件不用作空间中的位置（我们处理的是 3D，而不是 4D），而是用于称为透视分割的东西。 我们将在后面的章节中更深入地讨论向量。
        </note>

        <p>
          To set the output of the vertex shader we have to assign the position data to the predefined
          <var>gl_Position</var> variable which is a <code>vec4</code> behind the scenes. At the end of the <fun>main
          </fun> function, whatever we set <var>gl_Position</var>
          to will be used as the output of the vertex shader. Since our input is
          a vector of size 3 we have to cast this to a vector of size 4. We can
          do this by inserting the <code>vec3</code> values inside the constructor of <code>vec4</code> and set its
          <code>w</code> component to <code>1.0f</code> (we will explain why in a later chapter).
        </p>
        <p>要设置顶点着色器的输出，我们必须将位置数据分配给预定义的 gl_Position 变量，它是幕后的 vec4。 在 main 函数的最后，无论我们将 gl_Position 设置为什么，都将用作顶点着色器的输出。
          由于我们的输入是一个大小为 3 的向量，我们必须将其转换为大小为 4 的向量。我们可以通过将 vec3 值插入 vec4 的构造函数并将其 w 分量设置为 1.0f 来做到这一点（我们将在 后面的章节）。</p>

        <p>
          The current vertex shader is probably the most simple vertex shader we
          can imagine because we did no processing whatsoever on the input data
          and simply forwarded it to the shader's output. In real applications the
          input data is usually not already in normalized device coordinates so
          we first have to transform the input data to coordinates that fall
          within OpenGL's visible region.
        </p>
        <p>当前的顶点着色器可能是我们能想象到的最简单的顶点着色器，因为我们没有对输入数据进行任何处理，只是将其转发到着色器的输出。 在实际应用中，输入数据通常不在规范化的设备坐标中，因此我们首先必须将输入数据转换为落在
          OpenGL 可见区域内的坐标。</p>

        <h2>Compiling a shader</h2>
        <p>
          We take the source code for the vertex shader and store it in a const C string at the top of the code file for
          now:
        </p>
        <p>我们获取顶点着色器的源代码并将其存储在代码文件顶部的常量 C 字符串中：</p>

        <pre><code class=" hljs cpp">
<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *vertexShaderSource = <span class="hljs-string">"#version 330 core\n"</span>
    <span class="hljs-string">"layout (location = 0) in vec3 aPos;\n"</span>
    <span class="hljs-string">"void main()\n"</span>
    <span class="hljs-string">"{\n"</span>
    <span class="hljs-string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span>
    <span class="hljs-string">"}\0"</span>;
</code></pre>

        <p>
          In order for OpenGL to use the shader it has to dynamically compile it
          at run-time from its source code. The first thing we need to do is
          create a shader object, again referenced by an ID. So we store the
          vertex shader as an <code>unsigned int</code> and create the shader with <fun>
            <function id="37">glCreateShader</function>
          </fun>:
        </p>
        <p>为了让 OpenGL 使用着色器，它必须在运行时从其源代码动态编译它。 我们需要做的第一件事是创建一个着色器对象，同样由一个 ID 引用。 所以我们将顶点着色器存储为一个无符号整数并使用 glCreateShader
          创建着色器：</p>

        <pre><code class=" hljs cpp">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> vertexShader;
vertexShader = <function id="37">glCreateShader</function>(GL_VERTEX_SHADER);
</code></pre>

        <p>
          We provide the type of shader we want to create as an argument to <fun>
            <function id="37">glCreateShader</function>
          </fun>. Since we're creating a vertex shader we pass in <var>GL_VERTEX_SHADER</var>.
        </p>
        <p>我们提供我们想要创建的着色器类型作为 glCreateShader 的参数。 因为我们正在创建一个顶点着色器，所以我们传入 GL_VERTEX_SHADER。</p>

        <p>
          Next we attach the shader source code to the shader object and compile the shader:
        </p>
        <p>接下来我们将着色器源代码附加到着色器对象并编译着色器：</p>

        <pre class="cpp"><code class=" hljs ">
<function id="42">glShaderSource</function>(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, NULL);
<function id="38">glCompileShader</function>(vertexShader);
</code></pre>

        <p>
          The <fun>
            <function id="42">glShaderSource</function>
          </fun> function
          takes the shader object to compile to as its first argument. The second
          argument specifies how many strings we're passing as source code, which
          is only one. The third parameter is the actual source code of the vertex
          shader and we can leave the 4th parameter to <code>NULL</code>.
        </p>
        <p>glShaderSource 函数将要编译的着色器对象作为其第一个参数。 第二个参数指定我们将多少个字符串作为源代码传递，这只是一个。 第三个参数是顶点着色器的实际源代码，我们可以将第四个参数保留为 NULL。</p>

        <note>
          <p>
            You probably want to check if compilation was successful after the call to <fun>
              <function id="38">glCompileShader</function>
            </fun> and if not, what errors were found so you can fix those. Checking for compile-time errors is
            accomplished as follows:
          </p>
          <p>您可能想在调用 glCompileShader 后检查编译是否成功，如果没有，发现了哪些错误以便您可以修复这些错误。 检查编译时错误是按如下方式完成的：</p>

          <pre class="cpp"><code class=" hljs ">
<span class="hljs-keyword">int</span>  success;
<span class="hljs-keyword">char</span> infoLog[<span class="hljs-number">512</span>];
<function id="39">glGetShaderiv</function>(vertexShader, GL_COMPILE_STATUS, &amp;success);
</code></pre>

          <p>
            First we define an integer to indicate success and a storage
            container for the error messages (if any). Then we check if compilation
            was successful with <fun>
              <function id="39">glGetShaderiv</function>
            </fun>. If compilation failed, we should retrieve the error message with <fun>
              <function id="40">glGetShaderInfoLog</function>
            </fun> and print the error message.
          </p>
          <p>首先，我们定义一个整数来指示成功和错误消息（如果有）的存储容器。 然后我们使用 glGetShaderiv 检查编译是否成功。 如果编译失败，我们应该使用 glGetShaderInfoLog
            检索错误消息并打印错误消息。</p>

          <pre><code class=" hljs cpp">
<span class="hljs-keyword">if</span>(!success)
{
    <function id="40">glGetShaderInfoLog</function>(vertexShader, <span class="hljs-number">512</span>, NULL, infoLog);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</code></pre>
        </note>

        <p>
          If no errors were detected while compiling the vertex shader it is now compiled.
        </p>
        <p>如果在编译顶点着色器时未检测到错误，则现在已编译。</p>

        <h2>Fragment shader</h2>
        <p>
          The fragment shader is the second and final shader we're going to
          create for rendering a triangle. The fragment shader is all about
          calculating the color output of your pixels. To keep things simple the
          fragment shader will always output an orange-ish color.
        </p>
        <p>片段着色器是我们要创建的用于渲染三角形的第二个也是最后一个着色器。 片段着色器就是计算像素的颜色输出。 为了简单起见，片段着色器将始终输出橙色。</p>

        <note>
          Colors in computer graphics are represented as an array of 4 values:
          the red, green, blue and alpha (opacity) component, commonly abbreviated
          to RGBA. When defining a color in OpenGL or GLSL we set the strength of
          each component to a value between <code>0.0</code> and <code>1.0</code>. If, for example, we would set red to
          <code>1.0</code> and green to <code>1.0</code>
          we would get a mixture of both colors and get the color yellow. Given
          those 3 color components we can generate over 16 million different
          colors!
          <br><br>
          计算机图形中的颜色表示为 4 个值的数组：红色、绿色、蓝色和 alpha（不透明度）分量，通常缩写为 RGBA。 在 OpenGL 或 GLSL 中定义颜色时，我们将每个组件的强度设置为 0.0 到 1.0 之间的值。
          例如，如果我们将红色设置为 1.0，将绿色设置为 1.0，我们将得到两种颜色的混合并得到黄色。 鉴于这 3 个颜色分量，我们可以生成超过 1600 万种不同的颜色！
        </note>

        <pre><code class=" hljs cpp">
<span class="hljs-preprocessor">#version 330 core</span>
<span class="hljs-keyword">out</span> <span class="hljs-built_in">vec4</span> FragColor;

<span class="hljs-keyword">void</span> main()
{
    FragColor = <span class="hljs-built_in">vec4</span>(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.2f</span>, <span class="hljs-number">1.0f</span>);
} 
</code></pre>

        <p>
          The fragment shader only requires one output variable and that is a
          vector of size 4 that defines the final color output that we should
          calculate ourselves. We can declare output values with the <code>out</code> keyword, that we here promptly
          named <var>FragColor</var>. Next we simply assign a <code>vec4</code> to the color output as an orange color
          with an alpha value of <code>1.0</code> (<code>1.0</code> being completely opaque).
        </p>
        <p>片段着色器只需要一个输出变量，它是一个大小为 4 的向量，它定义了我们应该自己计算的最终颜色输出。 我们可以使用 out 关键字声明输出值，我们在此将其命名为 FragColor。 接下来，我们简单地将 vec4
          分配给颜色输出，作为橙色，alpha 值为 1.0（1.0 是完全不透明的）。</p>

        <p>
          The process for compiling a fragment shader is similar to the vertex shader, although this time we use the
          <var>GL_FRAGMENT_SHADER</var> constant as the shader type:
        </p>
        <p>编译片段着色器的过程类似于顶点着色器，尽管这次我们使用 GL_FRAGMENT_SHADER 常量作为着色器类型：</p>

        <pre class="cpp"><code class=" hljs ">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fragmentShader;
fragmentShader = <function id="37">glCreateShader</function>(GL_FRAGMENT_SHADER);
<function id="42">glShaderSource</function>(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, NULL);
<function id="38">glCompileShader</function>(fragmentShader);
</code></pre>

        <p>
          Both the shaders are now compiled and the only thing left to do is link both shader objects into a <def>shader
            program</def> that we can use for rendering. Make sure to check for compile errors here as well!
        </p>
        <p>两个着色器现在都已编译，唯一剩下要做的就是将两个着色器对象链接到我们可用于渲染的着色器程序中。 确保也在这里检查编译错误！</p>

        <h3>Shader program</h3>
        <p>
          A shader program object is the final linked version of multiple shaders
          combined. To use the recently compiled shaders we have to <def>link</def>
          them to a shader program object and then activate this shader program
          when rendering objects. The activated shader program's shaders will be
          used when we issue render calls.
        </p>
        <p>着色器程序对象是多个着色器组合的最终链接版本。 要使用最近编译的着色器，我们必须将它们链接到一个着色器程序对象，然后在渲染对象时激活这个着色器程序。 当我们发出渲染调用时，将使用激活的着色器程序的着色器。</p>

        <p>
          When linking the shaders into a program it links the outputs of each
          shader to the inputs of the next shader. This is also where you'll get
          linking errors if your outputs and inputs do not match. </p>
        <p>将着色器链接到程序中时，它将每个着色器的输出链接到下一个着色器的输入。 如果您的输出和输入不匹配，这也是您会遇到链接错误的地方。</p>

        <p>
          Creating a program object is easy:
        </p>

        <pre><code class=" hljs cpp">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> shaderProgram;
shaderProgram = <function id="36">glCreateProgram</function>();
</code></pre>

        <p>
          The <fun>
            <function id="36">glCreateProgram</function>
          </fun> function
          creates a program and returns the ID reference to the newly created
          program object. Now we need to attach the previously compiled shaders to
          the program object and then link them with <fun>
            <function id="35">glLinkProgram</function>
          </fun>:
        </p>
        <p>glCreateProgram 函数创建一个程序并将 ID 引用返回给新创建的程序对象。 现在我们需要将先前编译的着色器附加到程序对象，然后将它们与 glLinkProgram 链接：</p>

        <pre><code class=" hljs ">
<function id="34">glAttachShader</function>(shaderProgram, vertexShader);
<function id="34">glAttachShader</function>(shaderProgram, fragmentShader);
<function id="35">glLinkProgram</function>(shaderProgram);
</code></pre>

        <p>
          The code should be pretty self-explanatory, we attach the shaders to the program and link them via <fun>
            <function id="35">glLinkProgram</function>
          </fun>.
        </p>
        <p>代码应该是不言自明的，我们将着色器附加到程序并通过 glLinkProgram 链接它们。</p>

        <note>
          Just like shader compilation we can also check if linking a shader
          program failed and retrieve the corresponding log. However, instead of
          using <fun>
            <function id="39">glGetShaderiv</function>
          </fun> and <fun>
            <function id="40">glGetShaderInfoLog</function>
          </fun> we now use:

          <br><br>
          就像着色器编译一样，我们也可以检查链接着色器程序是否失败并检索相应的日志。 然而，我们现在使用的不是 glGetShaderiv 和 glGetShaderInfoLog：

          <pre class="cpp"><code class=" hljs ">
<function id="41">glGetProgramiv</function>(shaderProgram, GL_LINK_STATUS, &amp;success);
<span class="hljs-keyword">if</span>(!success) {
    glGetProgramInfoLog(shaderProgram, <span class="hljs-number">512</span>, NULL, infoLog);
    ...
}
</code></pre>
        </note>

        <p>
          The result is a program object that we can activate by calling <fun>
            <function id="28">glUseProgram</function>
          </fun> with the newly created program object as its argument:
        </p>
        <p>结果是一个程序对象，我们可以通过使用新创建的程序对象作为参数调用 glUseProgram 来激活它：</p>

        <pre><code class=" hljs ">
<function id="28">glUseProgram</function>(shaderProgram);
</code></pre>

        <p>
          Every shader and rendering call after <fun>
            <function id="28">glUseProgram</function>
          </fun> will now use this program object (and thus the shaders).
        </p>
        <p>glUseProgram 之后的每个着色器和渲染调用现在都将使用此程序对象（以及着色器）。</p>

        <p>
          Oh yeah, and don't forget to delete the shader objects once we've
          linked them into the program object; we no longer need them anymore:
        </p>
        <p>哦，是的，一旦我们将它们链接到程序对象中，不要忘记删除着色器对象； 我们不再需要它们了：</p>

        <pre><code class=" hljs ">
<function id="46">glDeleteShader</function>(vertexShader);
<function id="46">glDeleteShader</function>(fragmentShader);  
</code></pre>

        <p>
          Right now we sent the input vertex data to the GPU and instructed the
          GPU how it should process the vertex data within a vertex and fragment
          shader. We're almost there, but not quite yet. OpenGL does not yet know
          how it should interpret the vertex data in memory and how it should
          connect the vertex data to the vertex shader's attributes. We'll be nice
          and tell OpenGL how to do that.
        </p>
        <p>现在我们将输入的顶点数据发送到 GPU，并指示 GPU 如何在顶点和片段着色器中处理顶点数据。 我们快到了，但还不完全是。 OpenGL
          还不知道它应该如何解释内存中的顶点数据以及它应该如何将顶点数据连接到顶点着色器的属性。 我们会很友好地告诉 OpenGL 如何去做。</p>

        <h2>Linking Vertex Attributes</h2>
        <p>
          The vertex shader allows us to specify any input we want in the form
          of vertex attributes and while this allows for great flexibility, it
          does mean we have to manually specify what part of our input data goes
          to which vertex attribute in the vertex shader. This means we have to
          specify how OpenGL should interpret the vertex data before rendering.
        </p>
        <p>顶点着色器允许我们以顶点属性的形式指定我们想要的任何输入，虽然这具有很大的灵活性，但这确实意味着我们必须手动指定输入数据的哪一部分进入顶点着色器中的哪个顶点属性。 这意味着我们必须在渲染之前指定 OpenGL
          应该如何解释顶点数据。</p>

        <p>
          Our vertex buffer data is formatted as follows:
        </p>

        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/vertex_attribute_pointer.png" class="clean"
          alt="Vertex attribte pointer setup of OpenGL VBO">

        <ul>
          <li>The position data is stored as 32-bit (4 byte) floating point values.
            <br>
            位置数据存储为 32 位（4 字节）浮点值。
          </li>
          <li>Each position is composed of 3 of those values.
            <br>
            每个位置由其中 3 个值组成。

          </li>
          <li>There is no space (or other values) between each set of 3 values. The values are <def>tightly packed</def>
            in the array.
            <br>
            每组 3 个值之间没有空格（或其他值）。 这些值紧密地打包在数组中。
          </li>
          <li>The first value in the data is at the beginning of the buffer.
<br>数据中的第一个值位于缓冲区的开头。

          </li>
        </ul>

        <p>
          With this knowledge we can tell OpenGL how it should interpret the vertex data (per vertex attribute) using
          <fun>
            <function id="30">glVertexAttribPointer</function>
          </fun>:
        </p>
        <p>
          有了这些知识，我们可以告诉 OpenGL 它应该如何使用 glVertexAttribPointer 解释顶点数据（每个顶点属性）：
        </p>

        <pre class="cpp"><code class=" hljs ">
<function id="30">glVertexAttribPointer</function>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">GL_FLOAT</span>, <span class="hljs-built_in">GL_FALSE</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);
<function id="29"><function id="60">glEnable</function>VertexAttribArray</function>(<span class="hljs-number">0</span>);  
</code></pre>

        <p>
          The function <fun>
            <function id="30">glVertexAttribPointer</function>
          </fun> has quite a few parameters so let's carefully walk through them:
        </p><p>函数 glVertexAttribPointer 有很多参数，所以让我们仔细看一下它们：</p>

        <ul>
          <li>The first parameter specifies which vertex attribute we want to configure. Remember that we specified the
            location of the <var>position</var> vertex attribute in the vertex shader with
            <code>layout (location = 0)</code>. This sets the location of the vertex attribute to <code>0</code> and
            since we want to pass data to this vertex attribute, we pass in <code>0</code>.
            <br>
            第一个参数指定我们要配置的顶点属性。 请记住，我们在带有布局的顶点着色器中指定了位置顶点属性的位置（location = 0）。 这会将顶点属性的位置设置为 0，因为我们要将数据传递给该顶点属性，所以我们传入 0。
          </li>

          <li>The next argument specifies the size of the vertex attribute. The vertex attribute is a <code>vec3</code>
            so it is composed of <code>3</code> values.
          <br>
          下一个参数指定顶点属性的大小。 顶点属性是一个 vec3，所以它由 3 个值组成。
          </li>

          <li>The third argument specifies the type of the data which is <var>GL_FLOAT</var> (a <code>vec*</code> in
            GLSL consists of floating point values).
          <br>第三个参数指定数据类型，它是 GL_FLOAT（GLSL 中的 vec* 由浮点值组成）。
          </li>

          <li>The next argument specifies if we want the data to be
            normalized. If we're inputting integer data types (int, byte) and we've
            set this to <var>GL_TRUE</var>, the integer data is normalized to <code>0</code> (or <code>-1</code> for
            signed data) and <code>1</code> when converted to float. This is not relevant for us so we'll leave this at
            <var>GL_FALSE</var>.
            <br>下一个参数指定我们是否要对数据进行规范化。 如果我们正在输入整数数据类型（int、byte）并将其设置为 GL_TRUE，则整数数据被规范化为 0（或 -1 对于有符号数据）和 1 转换为 float 时。 这与我们无关，所以我们将其保留在 GL_FALSE。
          </li>

          <li>The fifth argument is known as the <def>stride</def> and tells
            us the space between consecutive vertex attributes. Since the next set
            of position data is located exactly 3 times the size of a <code>float</code>
            away we specify that value as the stride. Note that since we know that
            the array is tightly packed (there is no space between the next vertex
            attribute value) we could've also specified the stride as <code>0</code>
            to let OpenGL determine the stride (this only works when values are
            tightly packed). Whenever we have more vertex attributes we have to
            carefully define the spacing between each vertex attribute but we'll get
            to see more examples of that later on.
          <br>
          第五个参数称为步幅，它告诉我们连续顶点属性之间的空间。 由于下一组位置数据恰好位于浮动距离大小的 3 倍，我们将该值指定为步幅。 请注意，由于我们知道数组是紧密打包的（下一个顶点属性值之间没有空格），我们还可以将步幅指定为 0 以让 OpenGL 确定步幅（这仅在值紧密打包时有效）。 每当我们有更多的顶点属性时，我们必须仔细定义每个顶点属性之间的间距，但我们稍后会看到更多这样的例子。
          </li>

          <li>The last parameter is of type <code>void*</code> and thus requires that weird cast. This is the <def>
              offset</def> of where the position data begins in the buffer. Since the position data is at the start of
            the data array this value is just <code>0</code>. We will explore this parameter in more detail later on

            <br>
            最后一个参数的类型为 void* ，因此需要进行奇怪的转换。 这是缓冲区中位置数据开始位置的偏移量。 由于位置数据位于数据数组的开头，因此该值仅为 0。稍后我们将更详细地探讨该参数
          </li>
        </ul>

        <note>
          Each vertex attribute takes its data from memory managed by a VBO and
          which VBO it takes its data from (you can have multiple VBOs) is
          determined by the VBO currently bound to <var>GL_ARRAY_BUFFER</var> when calling <fun>
            <function id="30">glVertexAttribPointer</function>
          </fun>. Since the previously defined <var>VBO</var> is still bound before calling <fun>
            <function id="30">glVertexAttribPointer</function>
          </fun> vertex attribute <code>0</code> is now associated with its vertex data.

          <br><br>
          每个顶点属性从 VBO 管理的内存中获取数据，从哪个 VBO（您可以有多个 VBO）获取数据由调用 glVertexAttribPointer 时当前绑定到 GL_ARRAY_BUFFER 的 VBO 确定。 由于先前定义的 VBO 在调用 glVertexAttribPointer 之前仍然绑定，因此顶点属性 0 现在与其顶点数据相关联。
        </note>


        <p>
          Now that we specified how OpenGL should interpret the vertex data we should also enable the vertex attribute
          with <fun>
            <function id="29">
              <function id="60">glEnable</function>VertexAttribArray
            </function>
          </fun>
          giving the vertex attribute location as its argument; vertex attributes
          are disabled by default. From that point on we have everything set up:
          we initialized the vertex data in a buffer using a vertex buffer object,
          set up a vertex and fragment shader and told OpenGL how to link the
          vertex data to the vertex shader's vertex attributes. Drawing an object
          in OpenGL would now look something like this:
        </p><p>现在我们指定了 OpenGL 应该如何解释顶点数据，我们还应该使用 glEnableVertexAttribArray 启用顶点属性，并将顶点属性位置作为其参数； 默认情况下禁用顶点属性。 从那时起，我们已经设置好了一切：我们使用顶点缓冲区对象初始化缓冲区中的顶点数据，设置顶点和片段着色器，并告诉 OpenGL 如何将顶点数据链接到顶点着色器的顶点属性。 在 OpenGL 中绘制对象现在看起来像这样：</p>

        <pre><code class=" hljs cpp">
<span class="hljs-comment">// 0. copy our vertices array in a buffer for OpenGL to use</span>
<function id="32">glBindBuffer</function>(GL_ARRAY_BUFFER, VBO);
<function id="31">glBufferData</function>(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);
<span class="hljs-comment">// 1. then set the vertex attributes pointers</span>
<function id="30">glVertexAttribPointer</function>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">GL_FLOAT</span>, <span class="hljs-built_in">GL_FALSE</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);
<function id="29"><function id="60">glEnable</function>VertexAttribArray</function>(<span class="hljs-number">0</span>);  
<span class="hljs-comment">// 2. use our shader program when we want to render an object</span>
<function id="28">glUseProgram</function>(shaderProgram);
<span class="hljs-comment">// 3. now draw the object </span>
someOpenGLFunctionThatDrawsOurTriangle();   
</code></pre>

        <p>
          We have to repeat this process every time we want to draw an object.
          It may not look like that much, but imagine if we have over 5 vertex
          attributes and perhaps 100s of different objects (which is not
          uncommon). Binding the appropriate buffer objects and configuring all
          vertex attributes for each of those objects quickly becomes a cumbersome
          process. What if there was some way we could store all these state
          configurations into an object and simply bind this object to restore its
          state?
        </p><p>每次我们要绘制一个对象时，我们都必须重复这个过程。 它可能看起来没有那么多，但想象一下，如果我们有超过 5 个顶点属性和可能有 100 个不同的对象（这并不罕见）。 绑定适当的缓冲区对象并为每个对象配置所有顶点属性很快就会成为一个繁琐的过程。 如果有某种方法可以将所有这些状态配置存储到一个对象中并简单地绑定该对象以恢复其状态会怎样？</p>

        <h3>Vertex Array Object</h3>
        <p>
          A <def>vertex array object</def> (also known as <def>VAO</def>) can be
          bound just like a vertex buffer object and any subsequent vertex
          attribute calls from that point on will be stored inside the VAO. This
          has the advantage that when configuring vertex attribute pointers you
          only have to make those calls once and whenever we want to draw the
          object, we can just bind the corresponding VAO. This makes switching
          between different vertex data and attribute configurations as easy as
          binding a different VAO. All the state we just set is stored inside the
          VAO.
        </p>
        <p>顶点数组对象（也称为 VAO）可以像顶点缓冲区对象一样绑定，并且从该点开始的任何后续顶点属性调用都将存储在 VAO 中。 这样做的好处是，在配置顶点属性指针时，您只需调用一次，每当我们想要绘制对象时，我们只需绑定相应的 VAO 即可。 这使得在不同的顶点数据和属性配置之间切换就像绑定不同的 VAO 一样容易。 我们刚刚设置的所有状态都存储在 VAO 中。</p>

        <warning>
          Core OpenGL <strong>requires</strong> that we use a VAO so it knows
          what to do with our vertex inputs. If we fail to bind a VAO, OpenGL will
          most likely refuse to draw anything.

          <br><br>
          Core OpenGL 要求我们使用 VAO，以便它知道如何处理我们的顶点输入。 如果我们未能绑定 VAO，OpenGL 很可能会拒绝绘制任何东西。
        </warning>

        <p>
          A vertex array object stores the following:
        </p>
        <p>
          顶点数组对象存储以下内容：
        </p>

        <ul>
          <li>Calls to <fun>
              <function id="29">
                <function id="60">glEnable</function>VertexAttribArray
              </function>
            </fun> or <fun>glDisableVertexAttribArray</fun>.
          <br>
          调用 glEnableVertexAttribArray 或 glDisableVertexAttribArray。
          </li>
          <li>Vertex attribute configurations via <fun>
              <function id="30">glVertexAttribPointer</function>
            </fun>.
          <br>
          通过 glVertexAttribPointer 进行顶点属性配置。
          </li>
          <li>Vertex buffer objects associated with vertex attributes by calls to <fun>
              <function id="30">glVertexAttribPointer</function>
            </fun>.
          <br>
          通过调用 glVertexAttribPointer 与顶点属性关联的顶点缓冲区对象。
          </li>
        </ul>

        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/vertex_array_objects.png" class="clean"
          alt="Image of how a VAO (Vertex Array Object) operates and what it stores in OpenGL">

        <p>
          The process to generate a VAO looks similar to that of a VBO:
        </p><p>
          生成 VAO 的过程与生成 VBO 的过程类似：
        </p>

        <pre class="cpp"><code class=" hljs ">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VAO;
<function id="33">glGenVertexArrays</function>(<span class="hljs-number">1</span>, &amp;VAO);  
</code></pre>

        <p>
          To use a VAO all you have to do is bind the VAO using <fun>
            <function id="27">glBindVertexArray</function>
          </fun>.
          From that point on we should bind/configure the corresponding VBO(s)
          and attribute pointer(s) and then unbind the VAO for later use. As soon
          as we want to draw an object, we simply bind the VAO with the preferred
          settings before drawing the object and that is it. In code this would
          look a bit like this:
        </p><p>要使用 VAO，您所要做的就是使用 glBindVertexArray 绑定 VAO。 从那时起，我们应该绑定/配置相应的 VBO(s) 和属性指针，然后取消绑定 VAO 以备后用。 一旦我们想要绘制一个对象，我们只需在绘制对象之前将 VAO 与首选设置绑定即可。 在代码中，这看起来有点像这样：</p>

        <pre><code class=" hljs cpp">
<span class="hljs-comment">// ..:: Initialization code (done once (unless your object frequently changes)) :: ..</span>
<span class="hljs-comment">// 1. bind Vertex Array Object</span>
<function id="27">glBindVertexArray</function>(VAO);
<span class="hljs-comment">// 2. copy our vertices array in a buffer for OpenGL to use</span>
<function id="32">glBindBuffer</function>(GL_ARRAY_BUFFER, VBO);
<function id="31">glBufferData</function>(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);
<span class="hljs-comment">// 3. then set our vertex attributes pointers</span>
<function id="30">glVertexAttribPointer</function>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">GL_FLOAT</span>, <span class="hljs-built_in">GL_FALSE</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);
<function id="29"><function id="60">glEnable</function>VertexAttribArray</function>(<span class="hljs-number">0</span>);  

  
[...]

<span class="hljs-comment">// ..:: Drawing code (in render loop) :: ..</span>
<span class="hljs-comment">// 4. draw the object</span>
<function id="28">glUseProgram</function>(shaderProgram);
<function id="27">glBindVertexArray</function>(VAO);
someOpenGLFunctionThatDrawsOurTriangle();   
</code></pre>

        <p>
          And that is it! Everything we did the last few million pages led up to
          this moment, a VAO that stores our vertex attribute configuration and
          which VBO to use. Usually when you have multiple objects you want to
          draw, you first generate/configure all the VAOs (and thus the required
          VBO and attribute pointers) and store those for later use. The moment we
          want to draw one of our objects, we take the corresponding VAO, bind
          it, then draw the object and unbind the VAO again.
        </p><p>就是这样！ 我们在最后几百万页所做的一切都导致了这一刻，一个 VAO 存储了我们的顶点属性配置和要使用的 VBO。 通常当你有多个你想要绘制的对象时，你首先生成/配置所有的 VAO（以及因此所需的 VBO 和属性指针）并存储它们以备后用。 当我们想要绘制一个对象时，我们获取相应的 VAO，绑定它，然后绘制对象并再次取消绑定 VAO。</p>

        <h3>The triangle we've all been waiting for</h3>
        <p>
          To draw our objects of choice, OpenGL provides us with the <fun>
            <function id="1">glDrawArrays</function>
          </fun>
          function that draws primitives using the currently active shader, the
          previously defined vertex attribute configuration and with the VBO's
          vertex data (indirectly bound via the VAO).
        </p><p>为了绘制我们选择的对象，OpenGL 为我们提供了 glDrawArrays 函数，该函数使用当前活动的着色器、先前定义的顶点属性配置和 VBO 的顶点数据（通过 VAO 间接绑定）绘制图元。</p>

        <pre class="cpp"><code class=" hljs ">
<function id="28">glUseProgram</function>(shaderProgram);
<function id="27">glBindVertexArray</function>(VAO);
<function id="1">glDrawArrays</function>(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
</code></pre>

        <p>
          The <fun>
            <function id="1">glDrawArrays</function>
          </fun> function takes
          as its first argument the OpenGL primitive type we would like to draw.
          Since I said at the start we wanted to draw a triangle, and I don't like
          lying to you, we pass in <var>GL_TRIANGLES</var>. The second argument specifies the starting index of the
          vertex array we'd like to draw; we just leave this at <code>0</code>. The last argument specifies how many
          vertices we want to draw, which is <code>3</code> (we only render 1 triangle from our data, which is exactly 3
          vertices long).
        </p><p>glDrawArrays 函数将我们想要绘制的 OpenGL 基元类型作为它的第一个参数。 因为我一开始就说我们要画一个三角形，我不想骗你，所以我们传入 GL_TRIANGLES。 第二个参数指定我们要绘制的顶点数组的起始索引； 我们只是将其保留为 0。最后一个参数指定我们要绘制多少个顶点，即 3（我们只从数据中渲染 1 个三角形，正好是 3 个顶点长）。</p>

        <p>
          Now try to compile the code and work your way backwards if any errors
          popped up. As soon as your application compiles, you should see the
          following result:
        </p><p>现在尝试编译代码并在出现任何错误时向后工作。 一旦您的应用程序编译完成，您应该会看到以下结果：</p>

        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/hellotriangle.png" class="clean"
          alt="An image of a basic triangle rendered in modern OpenGL" width="600px">

        <p>
          The source code for the complete program can be found <a
            href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.1.hello_triangle/hello_triangle.cpp"
            target="_blank">here</a> .
        </p>

        <p>
          If your output does not look the same you probably did something wrong
          along the way so check the complete source code and see if you missed
          anything.
        </p><p>如果你的输出看起来不一样，你可能在这个过程中做错了什么，所以检查完整的源代码，看看你是否遗漏了什么。</p>

        <h2> Element Buffer Objects </h2>
        <p>
          There is one last thing we'd like to discuss when rendering vertices and that is <def>element buffer objects
          </def>
          abbreviated to EBO. To explain how element buffer objects work it's
          best to give an example: suppose we want to draw a rectangle instead of a
          triangle. We can draw a rectangle using two triangles (OpenGL mainly
          works with triangles). This will generate the following set of vertices:
        </p>

        <pre><code class=" hljs cpp">	
<span class="hljs-keyword">float</span> vertices[] = {
    <span class="hljs-comment">// first triangle</span>
     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// top right</span>
     <span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom right</span>
    -<span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// top left </span>
    <span class="hljs-comment">// second triangle</span>
     <span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom right</span>
    -<span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom left</span>
    -<span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// top left</span>
}; 
</code></pre>

        <p>
          As you can see, there is some overlap on the vertices specified. We specify <code>bottom right</code> and
          <code>top left</code>
          twice! This is an overhead of 50% since the same rectangle could also
          be specified with only 4 vertices, instead of 6. This will only get
          worse as soon as we have more complex models that have over 1000s of
          triangles where there will be large chunks that overlap. What would be a
          better solution is to store only the unique vertices and then specify
          the order at which we want to draw these vertices in. In that case we
          would only have to store 4 vertices for the rectangle, and then just
          specify at which order we'd like to draw them. Wouldn't it be great if
          OpenGL provided us with a feature like that?
        </p>

        <p>
          Thankfully, element buffer objects work exactly like that. An EBO is a
          buffer, just like a vertex buffer object, that stores indices that
          OpenGL uses to decide what vertices to draw. This so called <def>indexed drawing</def>
          is exactly the solution to our problem. To get started we first have to
          specify the (unique) vertices and the indices to draw them as a
          rectangle:
        </p>

        <pre><code class=" hljs cpp">
<span class="hljs-keyword">float</span> vertices[] = {
     <span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// top right</span>
     <span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom right</span>
    -<span class="hljs-number">0.5f</span>, -<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>,  <span class="hljs-comment">// bottom left</span>
    -<span class="hljs-number">0.5f</span>,  <span class="hljs-number">0.5f</span>, <span class="hljs-number">0.0f</span>   <span class="hljs-comment">// top left </span>
};
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> indices[] = {  <span class="hljs-comment">// note that we start from 0!</span>
    <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,   <span class="hljs-comment">// first triangle</span>
    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>    <span class="hljs-comment">// second triangle</span>
};  
</code></pre>

        <p>
          You can see that, when using indices, we only need 4 vertices instead of 6. Next we need to create the element
          buffer object:
        </p>

        <pre class="cpp"><code class=" hljs ">
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> EBO;
<function id="12">glGenBuffers</function>(<span class="hljs-number">1</span>, &amp;EBO);
</code></pre>

        <p>
          Similar to the VBO we bind the EBO and copy the indices into the buffer with <fun>
            <function id="31">glBufferData</function>
          </fun>. Also, just like the VBO we want to place those calls between a bind and an unbind call, although this
          time we specify <var>GL_ELEMENT_ARRAY_BUFFER</var> as the buffer type.
        </p>

        <pre><code class=" hljs cpp">
<function id="32">glBindBuffer</function>(GL_ELEMENT_ARRAY_BUFFER, EBO);
<function id="31">glBufferData</function>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW); 
</code></pre>

        <p>
          Note that we're now giving <var>GL_ELEMENT_ARRAY_BUFFER</var> as the buffer target. The last thing left to do
          is replace the <fun>
            <function id="1">glDrawArrays</function>
          </fun> call with <fun>
            <function id="2">glDrawElements</function>
          </fun> to indicate we want to render the triangles from an index buffer. When using <fun>
            <function id="2">glDrawElements</function>
          </fun> we're going to draw using indices provided in the element buffer object currently bound:
        </p>

        <pre class="cpp"><code class=" hljs ">
<function id="32">glBindBuffer</function>(GL_ELEMENT_ARRAY_BUFFER, EBO);
<function id="2">glDrawElements</function>(GL_TRIANGLES, <span class="hljs-number">6</span>, <span class="hljs-built_in">GL_UNSIGNED_INT</span>, <span class="hljs-number">0</span>);
</code></pre>

        <p>
          The first argument specifies the mode we want to draw in, similar to <fun>
            <function id="1">glDrawArrays</function>
          </fun>.
          The second argument is the count or number of elements we'd like to
          draw. We specified 6 indices so we want to draw 6 vertices in total. The
          third argument is the type of the indices which is of type <var>GL_UNSIGNED_INT</var>.
          The last argument allows us to specify an offset in the EBO (or pass in
          an index array, but that is when you're not using element buffer
          objects), but we're just going to leave this at 0.
        </p>

        <p>
          The <fun>
            <function id="2">glDrawElements</function>
          </fun> function takes its indices from the EBO currently bound to the <var>GL_ELEMENT_ARRAY_BUFFER</var>
          target. This means we have to bind the corresponding EBO each time we
          want to render an object with indices which again is a bit cumbersome.
          It just so happens that a vertex array object also keeps track of
          element buffer object bindings. The last element buffer object that gets
          bound while a VAO is bound, is stored as the VAO's element buffer
          object. Binding to a VAO then also automatically binds that EBO.
        </p>

        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/vertex_array_objects_ebo.png" class="clean"
          alt="Image of VAO's structure / what it stores now also with EBO bindings.">

        <warning>
          A VAO stores the <fun>
            <function id="32">glBindBuffer</function>
          </fun> calls when the target is <var>GL_ELEMENT_ARRAY_BUFFER</var>.
          This also means it stores its unbind calls so make sure you don't
          unbind the element array buffer before unbinding your VAO, otherwise it
          doesn't have an EBO configured.
        </warning>

        <p>
          The resulting initialization and drawing code now looks something like this:
        </p>

        <pre><code class=" hljs cpp">
<span class="hljs-comment">// ..:: Initialization code :: ..</span>
<span class="hljs-comment">// 1. bind Vertex Array Object</span>
<function id="27">glBindVertexArray</function>(VAO);
<span class="hljs-comment">// 2. copy our vertices array in a vertex buffer for OpenGL to use</span>
<function id="32">glBindBuffer</function>(GL_ARRAY_BUFFER, VBO);
<function id="31">glBufferData</function>(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);
<span class="hljs-comment">// 3. copy our index array in a element buffer for OpenGL to use</span>
<function id="32">glBindBuffer</function>(GL_ELEMENT_ARRAY_BUFFER, EBO);
<function id="31">glBufferData</function>(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);
<span class="hljs-comment">// 4. then set the vertex attributes pointers</span>
<function id="30">glVertexAttribPointer</function>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">GL_FLOAT</span>, <span class="hljs-built_in">GL_FALSE</span>, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);
<function id="29"><function id="60">glEnable</function>VertexAttribArray</function>(<span class="hljs-number">0</span>);  

[...]
  
<span class="hljs-comment">// ..:: Drawing code (in render loop) :: ..</span>
<function id="28">glUseProgram</function>(shaderProgram);
<function id="27">glBindVertexArray</function>(VAO);
<function id="2">glDrawElements</function>(GL_TRIANGLES, <span class="hljs-number">6</span>, <span class="hljs-built_in">GL_UNSIGNED_INT</span>, <span class="hljs-number">0</span>);
<function id="27">glBindVertexArray</function>(<span class="hljs-number">0</span>);
</code></pre>

        <p>
          Running the program should give an image as depicted below. The left
          image should look familiar and the right image is the rectangle drawn in
          <def>wireframe mode</def>. The wireframe rectangle shows that the rectangle indeed consists of two triangles.
        </p>

        <img src="LearnOpenGL%20-%20Hello%20Triangle_files/hellotriangle2.png" class="clean"
          alt="A rectangle drawn using indexed rendering in OpenGL" width="800px">

        <note>
          <strong>Wireframe mode</strong><br>
          To draw your triangles in wireframe mode, you can configure how OpenGL draws its primitives via
          <code><function id="43">glPolygonMode</function>(GL_FRONT_AND_BACK, GL_LINE)</code>.
          The first argument says we want to apply it to the front and back of
          all triangles and the second line tells us to draw them as lines. Any
          subsequent drawing calls will render the triangles in wireframe mode
          until we set it back to its default using
          <code><function id="43">glPolygonMode</function>(GL_FRONT_AND_BACK, GL_FILL)</code>.
        </note>

        <p>
          If you have any errors, work your way backwards and see if you missed anything. You can find the complete
          source code <a
            href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.2.hello_triangle_indexed/hello_triangle_indexed.cpp"
            target="_blank">here</a>.
        </p>

        <p>
          If you managed to draw a triangle or a rectangle just like we did then
          congratulations, you managed to make it past one of the hardest parts
          of modern OpenGL: drawing your first triangle. This is a difficult part
          since there is a large chunk of knowledge required before being able to
          draw your first triangle. Thankfully, we now made it past that barrier
          and the upcoming chapters will hopefully be much easier to understand.
        </p>

        <h2>Additional resources</h2>
        <ul>
          <li><a href="http://antongerdelan.net/opengl/hellotriangle.html"
              target="_blank">antongerdelan.net/hellotriangle</a>: Anton Gerdelan's take on rendering the first
            triangle.</li>
          <li><a href="https://open.gl/drawing" target="_blank">open.gl/drawing</a>: Alexander Overvoorde's take on
            rendering the first triangle.</li>
          <li><a href="http://antongerdelan.net/opengl/vertexbuffers.html"
              target="_blank">antongerdelan.net/vertexbuffers</a>: some extra insights into vertex buffer objects.</li>
          <li><a href="https://learnopengl.com/In-Practice/Debugging"
              target="_blank">learnopengl.com/In-Practice/Debugging</a>:
            there are a lot of steps involved in this chapter; if you're stuck it
            may be worthwhile to read a bit on debugging in OpenGL (up until the
            debug output section).</li>
        </ul>

        <h1>Exercises</h1>
        <p>
          To really get a good grasp of the concepts discussed a few exercises
          were set up. It is advised to work through them before continuing to the
          next subject to make sure you get a good grasp of what's going on.
        </p>

        <ol>
          <li>Try to draw 2 triangles next to each other using <fun>
              <function id="1">glDrawArrays</function>
            </fun> by adding more vertices to your data: <a
              href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.3.hello_triangle_exercise1/hello_triangle_exercise1.cpp"
              target="_blank">solution</a>.</li>
          <li>Now create the same 2 triangles using two different VAOs and VBOs for their data: <a
              href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.4.hello_triangle_exercise2/hello_triangle_exercise2.cpp"
              target="_blank">solution</a>.</li>
          <li>Create two shader programs where the second program uses a
            different fragment shader that outputs the color yellow; draw both
            triangles again where one outputs the color yellow: <a
              href="https://learnopengl.com/code_viewer_gh.php?code=src/1.getting_started/2.5.hello_triangle_exercise3/hello_triangle_exercise3.cpp"
              target="_blank">solution</a>.</li>
        </ol>



      </div>

    </div> <!-- container div -->


  </div> <!-- super container div -->

  <iframe src="LearnOpenGL%20-%20Hello%20Triangle_files/sync.html"
    style="display: none; visibility: hidden;"></iframe><iframe style="display: none;"
    name="__tcfapiLocator"></iframe><img
    style="display: none !important; width: 1px !important; height: 1px !important;"
    src="LearnOpenGL%20-%20Hello%20Triangle_files/px_002.gif"><img
    style="display: none !important; width: 1px !important; height: 1px !important;"
    src="LearnOpenGL%20-%20Hello%20Triangle_files/favicon.ico"><img
    style="display: none !important; width: 1px !important; height: 1px !important;"
    src="LearnOpenGL%20-%20Hello%20Triangle_files/px.gif"><iframe style="display: none;"></iframe>
  <div id="confiant_tag_holder" style="display:none"></div><iframe
    src="LearnOpenGL%20-%20Hello%20Triangle_files/aframe.html" style="display: none;" width="0" height="0"></iframe>
</body><iframe sandbox="allow-scripts allow-same-origin" id="4457db96d88b7b718" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/index.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="446551eb8b807918" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://cm.g.doubleclick.net/pixel?google_nid=gumgum_dbm&amp;google_hm=dV85MmU2MTIzNC00NTJjLTQ2MmUtYmFhNS0zNzBiMTMwYTdkNjc=&amp;gdpr=0&amp;gdpr_consent="
  width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4471f6df45adc0a58" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/sync_002.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4482da4983528ec58" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/ixmatch.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4494500c5c9b2101" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://creativecdn.com/cm-notify?pi=gumgum" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="450f388a0d4d86218" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/async_usersync.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="451e52684e69dcde" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/a_007.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="452bf3b9a8e367e9" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://ups.analytics.yahoo.com/ups/58569/occ?https%3A%2F%2Fsync.adtelligent.com%2Fcsync%3Ft%3Da%26ep%3D545487%26extuid%3D%24UID"
  width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="453e8a2ee4045708" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://eb2.3lift.com/sync?us_privacy=1---&amp;" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="454f136f77f9a9748" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/a_008.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="455e936abb07de368" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/apacdex.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="456b76474a27b6b48" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/user_sync.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="457284c8657c64658" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://secure-assets.rubiconproject.com/utils/xapi/multi-sync.html?p=gumgum" width="0" height="0"
  frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4586147e2b1ba9718" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/usync_002.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="45989f26335f2f528" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/user_sync.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="460d15429f8ffc52" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://us-u.openx.net/w/1.0/pd?plm=10&amp;ph=e34aac42-0d1e-4d32-9386-02b79d6d1152&amp;gdpr=0&amp;us_privacy=1---"
  width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4611f9145e47b42b" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="https://ap.lijit.com/beacon?us_privacy=1---&amp;informer=12352498" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4624fa9616176de08" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/sync_004.html" width="0" height="0" frameborder="0">
</iframe><iframe sandbox="allow-scripts allow-same-origin" id="4631c2898d2f780f" allowtransparency="true"
  marginheight="0" marginwidth="0" hspace="0" vspace="0" style="height:0px;width:0px;display:none;" scrolling="no"
  src="LearnOpenGL%20-%20Hello%20Triangle_files/load-cookie.html" width="0" height="0" frameborder="0">
</iframe>

</html>